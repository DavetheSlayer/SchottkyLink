<!DOCTYPE html>
<html>
    <head>
        <title>SchottkyLink</title>
        <meta charset="UTF-8" />
        <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
        <link rel="stylesheet" href="../lib/keen-ui.min.css">
        <link rel="stylesheet" href="../css/style.css">
        <link rel="shortcut icon" href="../img/favicon.ico">
        <script type="text/javascript" src="../lib/vue.min.js"></script>
        <script type="text/javascript" src="../lib/keen-ui.min.js"></script>
        <script type="text/javascript" src="../lib/nunjucks.min.js"></script>
        <script type="text/javascript" src="scripts/raytrace.js"></script>
        <script type="text/javascript" src="scripts/util.js"></script>
        <script type="text/javascript" src="scripts/geometry.js"></script>
        <script type="text/javascript" src="scripts/presetParameter.js"></script>
        <script type="text/javascript" src="scripts/main.js"></script>
        <script id="render-vert" type="x-shader/x-vertex">
         attribute vec3 a_vertex;
         varying vec2 v_texCoord;
         void main(void){
             v_texCoord = a_vertex.xy * 0.5 + 0.5;
             gl_Position = vec4(a_vertex, 1.0);
         }
        </script>
        <script id="render-frag" type="x-shader/x-vertex">
         precision mediump float;
         varying vec2 v_texCoord;
         uniform sampler2D u_texture;

         const float DISPLAY_GAMMA_COEFF = 1. / 2.2;
         vec4 gammaCorrect(vec4 rgba) {
             return vec4((min(pow(rgba.r, DISPLAY_GAMMA_COEFF), 1.)),
                         (min(pow(rgba.g, DISPLAY_GAMMA_COEFF), 1.)),
                         (min(pow(rgba.b, DISPLAY_GAMMA_COEFF), 1.)),
                         rgba.a);
         }

         void main(void){
             gl_FragColor = gammaCorrect(texture2D(u_texture, v_texCoord));
         }
        </script>
        <script id="vs" type="x-shader/x-vertex">
         attribute vec2 a_vertex;

         void main(void){
             gl_Position = vec4(a_vertex, 0., 1.0);
         }
        </script>
        <script id="uniformVariables" type="x-shader/x-fragment">
         uniform sampler2D u_accTexture;
         uniform int u_numSamples;
         uniform float u_textureWeight;
         uniform vec2 u_iResolution;
         uniform int u_selectedObjectId;
         uniform int u_selectedObjectIndex;
         uniform int u_selectedComponentId;
         uniform int u_selectedAxis;
         // [eye, target, up, [fovDegree, 0, 0]]
         uniform vec3 u_camera[4];
         uniform int u_numIterations;
         uniform bool u_displayGenerators;

         {% for n  in range(0,  numSchottkySpheres ) %}
         uniform vec4 u_schottkySphere{{ n }};
         {% endfor %}

         {% for n  in range(0,  numSchottkySpheres ) %}
         float u_schottkySphere{{ n }}r2 = u_schottkySphere{{ n }}.w * u_schottkySphere{{ n }}.w;
         {% endfor %}

         {% for n  in range(0,  numBaseSpheres ) %}
         uniform vec4 u_baseSphere{{ n }};
         {% endfor %}

         {% for n in range(0,  numInfiniteSpheres ) %}
         // [center.x, center.y, center,z, size]
         uniform vec4 u_infiniteSphere{{ n }};
         uniform mat3 u_rotateInfiniteSphereMat3{{ n }};
         uniform mat3 u_invRotateInfiniteSphereMat3{{ n }};
         {% endfor %}

         {% for n in range(0,  numTransformByPlanes ) %}
         // [centerX, centerY, centerZ, distToP1, distToP2, size, thetaRad, phiRad, twist]
         uniform float u_transformByPlanes{{ n }}[9];
         uniform mat3 u_rotatePlaneMat3{{ n }};
         uniform mat3 u_invRotatePlaneMat3{{ n }};
         uniform mat3 u_twistPlaneMat3{{ n }};
         uniform mat3 u_invTwistPlaneMat3{{ n }};
         {% endfor %}

         {% for n in range(0, numTransformBySpheres) %}
         //[innerSphere, outerSphere, invertedSphere]
         uniform vec4 u_transformBySpheres{{ n }}[3];
         {% endfor %}

         {% for n in range(0, numCompoundParabolic) %}
         //[innerSphere, outerSphere, invertedSphere]
         uniform vec4 u_compoundParabolic{{ n }}[3];
         uniform mat3 u_compoundRotateMat3{{ n }};
         uniform mat3 u_invCompoundRotateMat3{{ n }};
         {% endfor %}

         {% for n in range(0, numCompoundLoxodromic) %}
         //[innerSphere, outerSphere, invertedSphere, s3, s4, p, q1, q2]
         uniform vec4 u_compoundLoxodromic{{ n }}[8];
         {% endfor %}

         {% for n in range(0, numParabolic) %}
         //[innerSphere, outerSphere, invertedSphere, sphereOnContactPoiont,
         // [contactPoint, 0]
         // [translatePoint, translateDist]]
         uniform vec4 u_parabolic{{ n }}[7];
         uniform mat3 u_parabolicRotationMat{{ n }}[2];
         {% endfor %}

        </script>
        <script id="constants" type="x-shader/x-fragment">
         const int ID_SCHOTTKY_SPHERE = 0;
         const int ID_BASE_SPHERE = 1;
         const int ID_TRANSFORM_BY_PLANES = 2;
         const int ID_TRANSFORM_BY_SPHERES = 3;
         const int ID_COMPOUND_PARABOLIC = 4;
         const int ID_COMPOUND_LOXODROMIC = 5;
         const int ID_INFINITE_SPHERE = 6;
         const int ID_PARABOLIC = 7;

         const int ID_AXIS_CYLINDER = 100;
         const int ID_KLEIN_ORBIT = 101;

         const float PI = 3.14159265359;
         const float PI_4 = 12.566368;
         const float EPSILON = 0.01;

         const vec3 BLACK = vec3(0);
         const vec3 WHITE = vec3(1);
         const vec3 LIGHT_GRAY = vec3(0.78);
         const vec3 RED = vec3(1, 0, 0);
         const vec3 GREEN = vec3(0, .78, 0);
         const vec3 BLUE = vec3(0, 0, 1);
         const vec3 YELLOW = vec3(1, 1, 0);
         const vec3 PINK = vec3(.78, 0, .78);
         const vec3 LIGHT_BLUE = vec3(0, 1, 1);

         const vec3 AMBIENT_FACTOR = vec3(0.1);

         const float NO_HIT = 99999.;

         const int MTL_DIFFUSE = 0;
         const int MTL_TRANSPARENT = 1;
        </script>

        <script id="intersectFunctions" type="x-shadee/x-fragment">
         int g_mtl = MTL_DIFFUSE;
         int g_objId = -1;
         int g_objIndex = -1;
         int g_objComponentId = -1;
         bool g_isHit = false;

         vec4 intersectSphere(int objId, int objIndex, int objComponentId, int mtl,
                              vec3 sphereCenter, float radius,
                              vec3 rayOrigin, vec3 rayDir, vec4 isect){
             g_isHit = false;
             vec3 v = rayOrigin - sphereCenter;
             float b = dot(rayDir, v);
             float c = dot(v, v) - radius * radius;
             float d = b * b - c;
             if(d >= 0.){
                 float s = sqrt(d);
                 float t = -b - s;
                 if(t <= EPSILON) t = -b + s;
                 if(EPSILON < t && t < isect.x){
                     vec3 p = (rayOrigin + t * rayDir);
                     g_objId = objId;
                     g_objIndex = objIndex;
                     g_objComponentId = objComponentId;
                     g_mtl = mtl;
                     g_isHit = true;
                     return vec4(t, normalize(p - sphereCenter));
                 }
             }
             return isect;
         }

         vec4 intersectXYCylinder(int objId, int objIndex, int objComponentId, int mtl,
                                  float r, vec3 center,
                                  vec3 rayOrigin, vec3 rayDir, vec4 isect){
             g_isHit = false;
             rayOrigin = rayOrigin - center;
             float a = rayDir.x * rayDir.x + rayDir.y * rayDir.y;
             float b = 2. * ( rayOrigin.x * rayDir.x + rayOrigin.y * rayDir.y);
             float c = rayOrigin.x * rayOrigin.x + rayOrigin.y * rayOrigin.y - r * r;
             float d = b * b - 4. * a * c;
             if(d >= 0.){
                 float s = sqrt(d);
                 float t = (-b - s) / (2. * a);
                 if(t <= EPSILON) t = (-b + s) / (2. * a);
                 if(EPSILON < t && t < isect.x){
                     vec3 p = (rayOrigin + t * rayDir);
                     g_objId = objId;
                     g_objIndex = objIndex;
                     g_objComponentId = objComponentId;
                     g_mtl = mtl;
                     g_isHit = true;
                     return vec4(t, normalize(vec3(p.xy, 0)));
                 }
             }
             return isect;
         }

         vec4 intersectYZCylinder(int objId, int objIndex, int objComponentId, int mtl,
                                  float r, vec3 center,
                                  vec3 rayOrigin, vec3 rayDir, vec4 isect){
             g_isHit = false;
             rayOrigin = rayOrigin - center;
             float a = rayDir.z * rayDir.z + rayDir.y * rayDir.y;
             float b = 2. * ( rayOrigin.z * rayDir.z + rayOrigin.y * rayDir.y);
             float c = rayOrigin.z * rayOrigin.z + rayOrigin.y * rayOrigin.y - r * r;
             float d = b * b - 4. * a * c;
             if(d >= 0.){
                 float s = sqrt(d);
                 float t = (-b - s) / (2. * a);
                 if(t <= EPSILON) t = (-b + s) / (2. * a);
                 if(EPSILON < t && t < isect.x){
                     vec3 p = (rayOrigin + t * rayDir);
                     g_objId = objId;
                     g_objIndex = objIndex;
                     g_objComponentId = objComponentId;
                     g_mtl = mtl;
                     g_isHit = true;
                     return vec4(t, normalize(vec3(0, p.yz)));
                 }
             }
             return isect;
         }

         vec4 intersectXZCylinder(int objId, int objIndex, int objComponentId, int mtl,
                                  float r, vec3 center,
                                  vec3 rayOrigin, vec3 rayDir, vec4 isect){
             g_isHit = false;
             rayOrigin = rayOrigin - center;
             float a = rayDir.x * rayDir.x + rayDir.z * rayDir.z;
             float b = 2. * ( rayOrigin.x * rayDir.x + rayOrigin.z * rayDir.z);
             float c = rayOrigin.x * rayOrigin.x + rayOrigin.z * rayOrigin.z - r * r;
             float d = b * b - 4. * a * c;
             if(d >= 0.){
                 float s = sqrt(d);
                 float t = (-b - s) / (2. * a);
                 if(t <= EPSILON) t = (-b + s) / (2. * a);
                 if(EPSILON < t && t < isect.x){
                     vec3 p = (rayOrigin + t * rayDir);
                     g_objId = objId;
                     g_objIndex = objIndex;
                     g_objComponentId = objComponentId;
                     g_mtl = mtl;
                     g_isHit = true;
                     return vec4(t, normalize(vec3(p.x, 0, p.z)));
                 }
             }
             return isect;
         }

         // Represent a sphere which have infinite radius
         // default plane is aligned the z-axis
         // Rotation center is plane's center
         vec4 intersectInfiniteSphere(int objId, int objIndex, int objComponentId, int mtl,
                                      vec3 center, float size, mat3 rotation,
                                      vec3 rayOrigin, vec3 rayDir, vec4 isect){
             g_isHit = false;
             vec3 n = rotation * vec3(0, 0, 1);
             vec3 xAxis = rotation * vec3(1, 0, 0);
             vec3 yAxis = rotation * vec3(0, 1, 0);
             float d = -dot(center, n);
             float v = dot(n, rayDir);
             float t = -(dot(n, rayOrigin) + d) / v;
             if(EPSILON < t && t < isect.x){
                 vec3 p = rayOrigin + t * rayDir;
                 float hSize = size * .5;
                 float x = dot(p - center, xAxis);
                 float y = dot(p - center, yAxis);
                 if(-hSize <= x && x <= hSize &&
                    -hSize <= y && y <= hSize ){
                     g_objId = objId;
                     g_objIndex = objIndex;
                     g_objComponentId = objComponentId;
                     g_mtl = mtl;
                     g_isHit = true;
                     return vec4(t, n);
                 }
             }
             return isect;
         }

         vec4 intersectParallelPlanes (int objId, int objIndex, int mtl,
                                       vec3 center, float distPlane1, float distPlane2,
                                       float size, mat3 rotation, float twistDegree,
                                       vec3 rayOrigin, vec3 rayDir, vec4 isect){
             float theta = radians(twistDegree);
             float cosTheta = cos(theta);
             float sinTheta = sin(theta);
             mat3 twist = mat3(cosTheta, -sinTheta, 0,
                               sinTheta, cosTheta, 0,
                               0, 0, 1);
             isect = intersectInfiniteSphere(objId, objIndex, 0, mtl,
                                             rotation * (center + vec3(0, 0, distPlane1)), size, rotation,
                                             rayOrigin, rayDir, isect);
             isect = intersectInfiniteSphere(objId, objIndex, 1, mtl,
                                             rotation * (center + vec3(0, 0, distPlane2)), size, rotation * twist,
                                             rayOrigin, rayDir, isect);
             return isect;
         }

         vec2 distRotationTorus(const vec3 rayPos, const float radius, const float pipeRadius,
                                                                             const int xzComponentId, const int yzComponentId){
             vec2 q1 = vec2(length(vec2(length(rayPos.yz) - radius, rayPos.x)) - pipeRadius, yzComponentId);
             vec2 q2 = vec2(length(vec2(length(rayPos.xz) - radius, rayPos.y)) - pipeRadius, xzComponentId);
             return (q1.x < q2.x) ? q1 : q2;
         }

         vec4 intersectRotationTorus (int objId, int objIndex, int xzComponentId, int yzComponentId, int mtl,
                                      vec3 center, float radius, float pipeRadius, float marchThreshold,
                                      vec3 rayOrigin, vec3 rayDir, vec4 isect){
             vec3 origin = rayOrigin - center;
             vec2 dist;
             vec3 rayPos = origin;
             float rayLength = 0.;
             for(int i = 0 ; i < 300 ; i++){
                 dist = distRotationTorus(rayPos, radius, pipeRadius, xzComponentId, yzComponentId);
                 rayLength += dist.x;
                 rayPos = origin + rayDir * rayLength;
                 if(dist.x < marchThreshold) break;
             }
             if(dist.x < EPSILON && rayLength < isect.x){
                 g_objId = objId;
                 g_objIndex = objIndex;
                 g_objComponentId = int(dist.y);
                 g_mtl = mtl;
                 g_isHit = true;
                 const vec2 D = vec2(0.01, 0.);
                 return vec4(rayLength,
                             normalize(vec3(distRotationTorus(rayPos + D.xyy, radius, pipeRadius,
                                                              xzComponentId, yzComponentId).x -
                                            distRotationTorus(rayPos - D.xyy, radius, pipeRadius,
                                                              xzComponentId, yzComponentId).x,
                                            distRotationTorus(rayPos + D.yxy, radius, pipeRadius,
                                                              xzComponentId, yzComponentId).x -
                                            distRotationTorus(rayPos - D.yxy, radius, pipeRadius,
                                                              xzComponentId, yzComponentId).x,
                                            distRotationTorus(rayPos + D.yyx, radius, pipeRadius,
                                                              xzComponentId, yzComponentId).x -
                                            distRotationTorus(rayPos - D.yyx, radius, pipeRadius,
                                                              xzComponentId, yzComponentId).x)));
             }else{
                 return isect;
             }
         }
        </script>

        <script id="3dSchottkyTemplate" type="x-shader/x-fragment">
         precision mediump float;

         {% include uniformVariables %}

         // from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/
         vec2 rand2n(vec2 co, float sampleIndex) {
             vec2 seed = co * (sampleIndex + 1.0);
             seed+=vec2(-1,1);
             // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html
             return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),
                         fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));
         }

         {% include constants %}

         {% include intersectFunctions %}

         const vec3 LIGHT_DIR = normalize(vec3(0.0, 1., 0.5));
         const int MAX_TRACE_DEPTH = 7;
         float transparency = 0.8;
         vec3 calcColor(vec3 eye, vec3 ray){
             vec3 l = BLACK;
             float coeff = 1.0;
             for (int depth = 0 ; depth < MAX_TRACE_DEPTH ; depth++){
                 vec4 result = vec4(99999.);

                 {% for n  in range(0,  numSchottkySpheres ) %}
                 result = intersectSphere(ID_SCHOTTKY_SPHERE, {{ n }}, 0, MTL_DIFFUSE,
                                          u_schottkySphere{{ n }}.xyz, u_schottkySphere{{ n }}.w, eye, ray, result);

                 if(u_selectedObjectId == ID_SCHOTTKY_SPHERE &&
                    u_selectedObjectIndex == {{ n }}){
                     result = intersectYZCylinder(ID_AXIS_CYLINDER, {{ n }}, 0, MTL_DIFFUSE,
                                                  10., u_schottkySphere{{ n }}.xyz,
                                                  eye, ray, result);

                     result = intersectXZCylinder(ID_AXIS_CYLINDER, {{ n }}, 1, MTL_DIFFUSE,
                                                  10., u_schottkySphere{{ n }}.xyz,
                                                  eye, ray, result);
                     result = intersectXYCylinder(ID_AXIS_CYLINDER, {{ n }}, 2, MTL_DIFFUSE,
                                                  10., u_schottkySphere{{ n }}.xyz,
                                                  eye, ray, result);
                 }
                 {% endfor %}

                 {% for n in range(0,  numBaseSpheres ) %}
                 result = intersectSphere(ID_BASE_SPHERE, {{ n }}, 0, MTL_DIFFUSE,
                                          u_baseSphere{{ n }}.xyz, u_baseSphere{{ n }}.w, eye, ray, result);

                 if(u_selectedObjectId == ID_BASE_SPHERE &&
                    u_selectedObjectIndex == {{ n }}){
                     result = intersectYZCylinder(ID_AXIS_CYLINDER, {{ n }}, 0, MTL_DIFFUSE,
                                                  10., u_baseSphere{{ n }}.xyz,
                                                  eye, ray, result);
                     result = intersectXZCylinder(ID_AXIS_CYLINDER, {{ n }}, 1, MTL_DIFFUSE,
                                                  10., u_baseSphere{{ n }}.xyz,
                                                  eye, ray, result);
                     result = intersectXYCylinder(ID_AXIS_CYLINDER, {{ n }}, 2, MTL_DIFFUSE,
                                                  10., u_baseSphere{{ n }}.xyz,
                                                  eye, ray, result);
                 }
                 {% endfor %}

                 {% for n in range(0,  numInfiniteSpheres ) %}
                 result = intersectInfiniteSphere(ID_INFINITE_SPHERE, {{ n }}, 0, MTL_DIFFUSE,
                                                  u_infiniteSphere{{ n }}.xyz,
                                                  u_infiniteSphere{{ n }}.w,
                                                  u_rotateInfiniteSphereMat3{{ n }},
                                                  eye, ray, result);
                 if(u_selectedObjectId == ID_INFINITE_SPHERE &&
                    u_selectedObjectIndex == {{ n }}){
                     result = intersectRotationTorus(ID_INFINITE_SPHERE, {{ n }}, 4, 5, MTL_DIFFUSE,
                                                     u_infiniteSphere{{ n }}.xyz,
                                                     u_infiniteSphere{{ n }}.w * 0.5, 10., 0.001,
                                                     eye, ray, result);
                     result = intersectYZCylinder(ID_AXIS_CYLINDER, {{ n }}, 0, MTL_DIFFUSE,
                                                  10., u_infiniteSphere{{ n }}.xyz,
                                                  eye, ray, result);
                     result = intersectXZCylinder(ID_AXIS_CYLINDER, {{ n }}, 1, MTL_DIFFUSE,
                                                  10., u_infiniteSphere{{ n }}.xyz,
                                                  eye, ray, result);
                     result = intersectXYCylinder(ID_AXIS_CYLINDER, {{ n }}, 2, MTL_DIFFUSE,
                                                  10., u_infiniteSphere{{ n }}.xyz,
                                                  eye, ray, result);
                 }
                 {% endfor %}

                 {% for n in range(0,  numTransformByPlanes ) %}
                 result = intersectParallelPlanes(ID_TRANSFORM_BY_PLANES, {{ n }}, MTL_DIFFUSE,
                                                  vec3(u_transformByPlanes{{ n }}[0],
                                                       u_transformByPlanes{{ n }}[1],
                                                       u_transformByPlanes{{ n }}[2]),
                                                  u_transformByPlanes{{ n }}[3],
                                                  u_transformByPlanes{{ n }}[4],
                                                  u_transformByPlanes{{ n }}[5],
                                                  u_rotatePlaneMat3{{ n }},
                                                  u_transformByPlanes{{ n }}[8],
                                                  eye, ray, result);
                 if(u_selectedObjectId == ID_TRANSFORM_BY_PLANES &&
                    u_selectedObjectIndex == {{ n }} ){
                     result = intersectXYCylinder(ID_AXIS_CYLINDER, {{ n }}, 2, MTL_DIFFUSE,
                                                  10., vec3(0),
                                                  eye, ray, result);
                 }

                 {% endfor %}

                 {% for n in range(0, numCompoundParabolic) %}
                 result = intersectSphere(ID_COMPOUND_PARABOLIC, {{ n }}, 0, MTL_TRANSPARENT,
                                          u_compoundParabolic{{ n }}[0].xyz,
                                          u_compoundParabolic{{ n }}[0].w,
                                          eye, ray, result);
                 if(u_selectedObjectId == ID_COMPOUND_PARABOLIC &&
                    u_selectedObjectIndex == {{ n }} &&
                    u_selectedComponentId == 0){
                     result = intersectYZCylinder(ID_AXIS_CYLINDER, {{ n }}, 0, MTL_DIFFUSE,
                                                  10., u_compoundParabolic{{ n }}[0].xyz,
                                                  eye, ray, result);
                     result = intersectXZCylinder(ID_AXIS_CYLINDER, {{ n }}, 1, MTL_DIFFUSE,
                                                  10., u_compoundParabolic{{ n }}[0].xyz,
                                                  eye, ray, result);
                     result = intersectXYCylinder(ID_AXIS_CYLINDER, {{ n }}, 2, MTL_DIFFUSE,
                                                  10., u_compoundParabolic{{ n }}[0].xyz,
                                                  eye, ray, result);
                 }
                 result = intersectSphere(ID_COMPOUND_PARABOLIC, {{ n }}, 1, MTL_TRANSPARENT,
                                          u_compoundParabolic{{ n }}[1].xyz,
                                          u_compoundParabolic{{ n }}[1].w,
                                          eye, ray, result);
                 if(u_selectedObjectId == ID_COMPOUND_PARABOLIC &&
                    u_selectedObjectIndex == {{ n }} &&
                    u_selectedComponentId == 1){
                     result = intersectYZCylinder(ID_AXIS_CYLINDER, {{ n }}, 0, MTL_DIFFUSE,
                                                  10., u_compoundParabolic{{ n }}[1].xyz,
                                                  eye, ray, result);
                     result = intersectXZCylinder(ID_AXIS_CYLINDER, {{ n }}, 1, MTL_DIFFUSE,
                                                  10., u_compoundParabolic{{ n }}[1].xyz,
                                                  eye, ray, result);
                     result = intersectXYCylinder(ID_AXIS_CYLINDER, {{ n }}, 2, MTL_DIFFUSE,
                                                  10., u_compoundParabolic{{ n }}[1].xyz,
                                                  eye, ray, result);
                 }
                 result = intersectSphere(ID_COMPOUND_PARABOLIC, {{ n }}, 2, MTL_TRANSPARENT,
                                          u_compoundParabolic{{ n }}[2].xyz,
                                          u_compoundParabolic{{ n }}[2].w,
                                          eye, ray, result);
                 {% endfor %}

                 {% for n in range(0, numParabolic) %}
                 result = intersectSphere(ID_PARABOLIC, {{ n }}, 0, MTL_TRANSPARENT,
                                          u_parabolic{{ n }}[0].xyz,
                                          u_parabolic{{ n }}[0].w,
                                          eye, ray, result);
                 result = intersectSphere(ID_PARABOLIC, {{ n }}, 1, MTL_TRANSPARENT,
                                          u_parabolic{{ n }}[1].xyz,
                                          u_parabolic{{ n }}[1].w,
                                          eye, ray, result);
                 if(u_selectedObjectId == ID_PARABOLIC &&
                    u_selectedObjectIndex == {{ n }} &&
                    u_selectedComponentId == 1){
                     result = intersectYZCylinder(ID_AXIS_CYLINDER, {{ n }}, 0, MTL_DIFFUSE,
                                                  10., u_parabolic{{ n }}[1].xyz,
                                                  eye, ray, result);
                     result = intersectXZCylinder(ID_AXIS_CYLINDER, {{ n }}, 1, MTL_DIFFUSE,
                                                  10., u_parabolic{{ n }}[1].xyz,
                                                  eye, ray, result);
                     result = intersectXYCylinder(ID_AXIS_CYLINDER, {{ n }}, 2, MTL_DIFFUSE,
                                                  10., u_parabolic{{ n }}[1].xyz,
                                                  eye, ray, result);
                 }
                 result = intersectSphere(ID_PARABOLIC, {{ n }}, 2, MTL_TRANSPARENT,
                                          u_parabolic{{ n }}[2].xyz,
                                          u_parabolic{{ n }}[2].w,
                                          eye, ray, result);
                 result = intersectInfiniteSphere(ID_PARABOLIC, {{ n }}, 3, MTL_DIFFUSE,
                                                  u_parabolic{{ n }}[5].xyz,
                                                  1200.,
                                                  u_parabolicRotationMat{{ n }}[0],
                                                  eye, ray, result);
                 result = intersectInfiniteSphere(ID_PARABOLIC, {{ n }}, 3, MTL_DIFFUSE,
                                                  u_parabolic{{ n }}[6].xyz,
                                                  1200.,
                                                  u_parabolicRotationMat{{ n }}[0],
                                                  eye, ray, result);
                 {% endfor %}

                 {% for n in range(0, numTransformBySpheres) %}
                 result = intersectSphere(ID_TRANSFORM_BY_SPHERES, {{ n }}, 0, MTL_TRANSPARENT,
                                          u_transformBySpheres{{ n }}[0].xyz,
                                          u_transformBySpheres{{ n }}[0].w,
                                          eye, ray, result);
                 if(u_selectedObjectId == ID_TRANSFORM_BY_SPHERES &&
                    u_selectedObjectIndex == {{ n }} &&
                    u_selectedComponentId == 0){
                     result = intersectYZCylinder(ID_AXIS_CYLINDER, {{ n }}, 0, MTL_DIFFUSE,
                                                  10., u_transformBySpheres{{ n }}[0].xyz,
                                                  eye, ray, result);
                     result = intersectXZCylinder(ID_AXIS_CYLINDER, {{ n }}, 1, MTL_DIFFUSE,
                                                  10., u_transformBySpheres{{ n }}[0].xyz,
                                                  eye, ray, result);
                     result = intersectXYCylinder(ID_AXIS_CYLINDER, {{ n }}, 2, MTL_DIFFUSE,
                                                  10., u_transformBySpheres{{ n }}[0].xyz,
                                                  eye, ray, result);
                 }
                 result = intersectSphere(ID_TRANSFORM_BY_SPHERES, {{ n }}, 1, MTL_TRANSPARENT,
                                          u_transformBySpheres{{ n }}[1].xyz,
                                          u_transformBySpheres{{ n }}[1].w,
                                          eye, ray, result);
                 if(u_selectedObjectId == ID_TRANSFORM_BY_SPHERES &&
                    u_selectedObjectIndex == {{ n }} &&
                    u_selectedComponentId == 1){
                     result = intersectYZCylinder(ID_AXIS_CYLINDER, {{ n }}, 0, MTL_DIFFUSE,
                                                  10., u_transformBySpheres{{ n }}[1].xyz,
                                                  eye, ray, result);
                     result = intersectXZCylinder(ID_AXIS_CYLINDER, {{ n }}, 1, MTL_DIFFUSE,
                                                  10., u_transformBySpheres{{ n }}[1].xyz,
                                                  eye, ray, result);
                     result = intersectXYCylinder(ID_AXIS_CYLINDER, {{ n }}, 2, MTL_DIFFUSE,
                                                  10., u_transformBySpheres{{ n }}[1].xyz,
                                                  eye, ray, result);
                 }
                 result = intersectSphere(ID_TRANSFORM_BY_SPHERES, {{ n }}, 2, MTL_TRANSPARENT,
                                          u_transformBySpheres{{ n }}[2].xyz,
                                          u_transformBySpheres{{ n }}[2].w,
                                          eye, ray, result);
                 {% endfor %}

                 {% for n in range(0, numCompoundLoxodromic) %}
                 result = intersectSphere(ID_COMPOUND_LOXODROMIC, {{ n }}, 0, MTL_TRANSPARENT,
                                          u_compoundLoxodromic{{ n }}[0].xyz,
                                          u_compoundLoxodromic{{ n }}[0].w,
                                          eye, ray, result);
                 if(u_selectedObjectId == ID_COMPOUND_LOXODROMIC &&
                    u_selectedObjectIndex == {{ n }} &&
                    u_selectedComponentId == 0){
                     result = intersectYZCylinder(ID_AXIS_CYLINDER, {{ n }}, 0, MTL_DIFFUSE,
                                                  10., u_compoundLoxodromic{{ n }}[0].xyz,
                                                  eye, ray, result);
                     result = intersectXZCylinder(ID_AXIS_CYLINDER, {{ n }}, 1, MTL_DIFFUSE,
                                                  10., u_compoundLoxodromic{{ n }}[0].xyz,
                                                  eye, ray, result);
                     result = intersectXYCylinder(ID_AXIS_CYLINDER, {{ n }}, 2, MTL_DIFFUSE,
                                                  10., u_compoundLoxodromic{{ n }}[0].xyz,
                                                  eye, ray, result);
                 }
                 result = intersectSphere(ID_COMPOUND_LOXODROMIC, {{ n }}, 1, MTL_TRANSPARENT,
                                          u_compoundLoxodromic{{ n }}[1].xyz,
                                          u_compoundLoxodromic{{ n }}[1].w,
                                          eye, ray, result);
                 if(u_selectedObjectId == ID_COMPOUND_LOXODROMIC &&
                    u_selectedObjectIndex == {{ n }} &&
                    u_selectedComponentId == 1){
                     result = intersectYZCylinder(ID_AXIS_CYLINDER, {{ n }}, 0, MTL_DIFFUSE,
                                                  10., u_compoundLoxodromic{{ n }}[1].xyz,
                                                  eye, ray, result);
                     result = intersectXZCylinder(ID_AXIS_CYLINDER, {{ n }}, 1, MTL_DIFFUSE,
                                                  10., u_compoundLoxodromic{{ n }}[1].xyz,
                                                  eye, ray, result);
                     result = intersectXYCylinder(ID_AXIS_CYLINDER, {{ n }}, 2, MTL_DIFFUSE,
                                                  10., u_compoundLoxodromic{{ n }}[1].xyz,
                                                  eye, ray, result);
                 }
                 result = intersectSphere(ID_COMPOUND_LOXODROMIC, {{ n }}, 2, MTL_TRANSPARENT,
                                          u_compoundLoxodromic{{ n }}[2].xyz,
                                          u_compoundLoxodromic{{ n }}[2].w,
                                          eye, ray, result);
                 result = intersectSphere(ID_COMPOUND_LOXODROMIC, {{ n }}, 3, MTL_TRANSPARENT,
                                          u_compoundLoxodromic{{ n }}[3].xyz,
                                          u_compoundLoxodromic{{ n }}[3].w,
                                          eye, ray, result);
                 result = intersectSphere(ID_COMPOUND_LOXODROMIC, {{ n }}, 4, MTL_TRANSPARENT,
                                          u_compoundLoxodromic{{ n }}[4].xyz,
                                          u_compoundLoxodromic{{ n }}[4].w,
                                          eye, ray, result);
                 result = intersectSphere(ID_COMPOUND_LOXODROMIC, {{ n }}, 5, MTL_TRANSPARENT,
                                          u_compoundLoxodromic{{ n }}[5].xyz,
                                          50.,
                                          eye, ray, result);
                 if(u_selectedObjectId == ID_COMPOUND_LOXODROMIC &&
                    u_selectedObjectIndex == {{ n }} &&
                    u_selectedComponentId == 5){
                     result = intersectYZCylinder(ID_AXIS_CYLINDER, {{ n }}, 0, MTL_DIFFUSE,
                                                  10., u_compoundLoxodromic{{ n }}[5].xyz,
                                                  eye, ray, result);
                     result = intersectXZCylinder(ID_AXIS_CYLINDER, {{ n }}, 1, MTL_DIFFUSE,
                                                  10., u_compoundLoxodromic{{ n }}[5].xyz,
                                                  eye, ray, result);
                     result = intersectXYCylinder(ID_AXIS_CYLINDER, {{ n }}, 2, MTL_DIFFUSE,
                                                  10., u_compoundLoxodromic{{ n }}[5].xyz,
                                                  eye, ray, result);
                 }
                 result = intersectSphere(ID_COMPOUND_LOXODROMIC, {{ n }}, 6, MTL_TRANSPARENT,
                                          u_compoundLoxodromic{{ n }}[6].xyz,
                                          50.,
                                          eye, ray, result);
                 if(u_selectedObjectId == ID_COMPOUND_LOXODROMIC &&
                    u_selectedObjectIndex == {{ n }} &&
                    u_selectedComponentId == 6){
                     result = intersectYZCylinder(ID_AXIS_CYLINDER, {{ n }}, 0, MTL_DIFFUSE,
                                                  10., u_compoundLoxodromic{{ n }}[6].xyz,
                                                  eye, ray, result);
                     result = intersectXZCylinder(ID_AXIS_CYLINDER, {{ n }}, 1, MTL_DIFFUSE,
                                                  10., u_compoundLoxodromic{{ n }}[6].xyz,
                                                  eye, ray, result);
                     result = intersectXYCylinder(ID_AXIS_CYLINDER, {{ n }}, 2, MTL_DIFFUSE,
                                                  10., u_compoundLoxodromic{{ n }}[6].xyz,
                                                  eye, ray, result);
                 }
                 result = intersectSphere(ID_COMPOUND_LOXODROMIC, {{ n }}, 7, MTL_TRANSPARENT,
                                          u_compoundLoxodromic{{ n }}[7].xyz,
                                          50.,
                                          eye, ray, result);
                 if(u_selectedObjectId == ID_COMPOUND_LOXODROMIC &&
                    u_selectedObjectIndex == {{ n }} &&
                    u_selectedComponentId == 7){
                     result = intersectYZCylinder(ID_AXIS_CYLINDER, {{ n }}, 0, MTL_DIFFUSE,
                                                  10., u_compoundLoxodromic{{ n }}[7].xyz,
                                                  eye, ray, result);
                     result = intersectXZCylinder(ID_AXIS_CYLINDER, {{ n }}, 1, MTL_DIFFUSE,
                                                  10., u_compoundLoxodromic{{ n }}[7].xyz,
                                                  eye, ray, result);
                     result = intersectXYCylinder(ID_AXIS_CYLINDER, {{ n }}, 2, MTL_DIFFUSE,
                                                  10., u_compoundLoxodromic{{ n }}[7].xyz,
                                                  eye, ray, result);
                 }
                 {% endfor %}

                 if(result.x != 99999.){
                     vec3 matColor = LIGHT_GRAY;
                     if( g_objId == ID_SCHOTTKY_SPHERE){
                         g_mtl = MTL_TRANSPARENT;
                         matColor = (g_objIndex == u_selectedObjectIndex &&
                                     g_objId == u_selectedObjectId) ? RED : LIGHT_GRAY;
                     }else if(g_objId == ID_BASE_SPHERE){
                         matColor = (g_objId == u_selectedObjectId &&
                                     g_objIndex == u_selectedObjectIndex) ? RED : GREEN;
                     }else if(g_objId == ID_INFINITE_SPHERE){
                         matColor = (g_objComponentId == 0) ? BLUE : LIGHT_GRAY;
                         matColor = (g_objId == u_selectedObjectId &&
                                     g_objIndex == u_selectedObjectIndex &&
                                     g_objComponentId == u_selectedComponentId) ? RED : matColor;
                         matColor = (g_objId == u_selectedObjectId &&
                                     g_objIndex == u_selectedObjectIndex &&
                                     g_objComponentId == u_selectedAxis) ? RED : matColor;
                     }else if(g_objId == ID_AXIS_CYLINDER){
                         matColor = (g_objComponentId == u_selectedAxis) ? RED : LIGHT_GRAY;
                     }else if(g_objId == ID_TRANSFORM_BY_PLANES){
                         matColor = (g_objId == u_selectedObjectId &&
                                     g_objIndex == u_selectedObjectIndex &&
                                     g_objComponentId == u_selectedComponentId)?
                                    RED : BLUE;
                     }else if(g_objId == ID_TRANSFORM_BY_SPHERES){
                         matColor = (g_objComponentId == 0) ? LIGHT_BLUE : vec3(0.2, 0.2, 0.9);
                         matColor = (g_objComponentId == 1) ? YELLOW : matColor;
                         matColor = (g_objId == u_selectedObjectId &&
                                     g_objIndex == u_selectedObjectIndex &&
                                     g_objComponentId == u_selectedComponentId) ? RED : matColor;
                     }else if(g_objId == ID_COMPOUND_PARABOLIC){
                         matColor = (g_objComponentId == 0) ? LIGHT_BLUE : vec3(0.2, 0.2, 0.9);
                         matColor = (g_objComponentId == 1) ? YELLOW : matColor;
                         matColor = (g_objId == u_selectedObjectId &&
                                     g_objIndex == u_selectedObjectIndex &&
                                     g_objComponentId == u_selectedComponentId) ? RED : matColor;
                     }else if(g_objId == ID_COMPOUND_LOXODROMIC){
                         matColor = (g_objComponentId == 0) ? LIGHT_BLUE : vec3(0.2, 0.2, 0.9);
                         matColor = (g_objComponentId == 1) ? YELLOW : matColor;
                         matColor = (g_objComponentId == 3) ? PINK : matColor;
                         matColor = (g_objComponentId == 4) ? GREEN : matColor;
                         matColor = (g_objComponentId == 5) ? BLUE : matColor;
                         matColor = (g_objComponentId == 6) ? LIGHT_GRAY : matColor;
                         matColor = (g_objComponentId == 7) ? LIGHT_GRAY : matColor;
                         matColor = (g_objId == u_selectedObjectId &&
                                     g_objIndex == u_selectedObjectIndex &&
                                     g_objComponentId == u_selectedComponentId) ? RED : matColor;
                     }else if(g_objId == ID_PARABOLIC){
                         matColor = (g_objComponentId == 0) ? LIGHT_BLUE : vec3(0.2, 0.2, 0.9);
                         matColor = (g_objComponentId == 1) ? YELLOW : matColor;
                         matColor = (g_objComponentId == 3) ? RED : matColor;
                         matColor = (g_objId == u_selectedObjectId &&
                                     g_objIndex == u_selectedObjectIndex &&
                                     g_objComponentId == u_selectedComponentId) ? RED : matColor;
                     }

                     vec3 intersection = eye + ray * result.x;
                     vec3 normal = result.yzw;
                     // diffuse lighting by directionalLight
                     vec3 diffuse =  clamp(dot(normal, LIGHT_DIR), 0., 1.) * matColor;
                     vec3 ambient = matColor * AMBIENT_FACTOR;
                     if(g_mtl == MTL_TRANSPARENT){
                         coeff *= transparency;
                         l += (diffuse + ambient) * coeff;
                         eye = intersection + ray * 0.01;
                         continue;
                     }else{
                         l += (diffuse + ambient) * coeff;
                     }
                 }
                 break;
         }
             return l;
         }

         vec3 hsv2rgb(vec3 c){
             const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
             vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
             return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
         }

         vec3 calcRay (const vec3 eye, const vec3 target,
                                             const vec3 up, const float fov,
                                                                  const float width, const float height, const vec2 coord){
             float imagePlane = (height * .5) / tan(radians(fov) * .5);
             vec3 v = normalize(target - eye);
             vec3 focalXAxis = normalize(cross(v, up));
             vec3 focalYAxis =  normalize(cross(v, focalXAxis ));
             vec3 center = v * imagePlane;
             vec3 origin = center - (focalXAxis * (width  * .5)) - (focalYAxis * (height * .5));
             return normalize(origin + (focalXAxis * coord.x) + (focalYAxis * (height - coord.y)));
         }

         const float SAMPLE_NUM = 5.;
         void main(){
             vec3 sum = vec3(0);
             for(float i = 0. ; i < SAMPLE_NUM ; i++){
                 vec2 coordOffset = rand2n(gl_FragCoord.xy, i);

                 vec3 ray = calcRay(u_camera[0], u_camera[1], u_camera[2], u_camera[3].x,
                                    u_iResolution.x, u_iResolution.y,
                                    gl_FragCoord.xy + coordOffset);

                 sum += calcColor(u_camera[0], ray);
             }
             vec3 col = (sum/SAMPLE_NUM);

             vec3 texCol = texture2D(u_accTexture, gl_FragCoord.xy / u_iResolution).rgb;
             gl_FragColor = vec4(mix(col, texCol,
                                     u_textureWeight), 1.0);
         }
        </script>

        <script id="distKleinTemplate" type="x-shader/x-fragment">
         {% for n in range(0,  numTransformBySpheres ) %}
         float s0r2{{ n }} = u_transformBySpheres{{ n }}[0].w * u_transformBySpheres{{ n }}[0].w;
         float s1r2{{ n }} = u_transformBySpheres{{ n }}[1].w * u_transformBySpheres{{ n }}[1].w;
         {% endfor %}

         {% for n in range(0,  numParabolic ) %}
         float p0r2{{ n }} = u_parabolic{{ n }}[0].w * u_parabolic{{ n }}[0].w;
         float p1r2{{ n }} = u_parabolic{{ n }}[1].w * u_parabolic{{ n }}[1].w;
         float pFixedR2{{ n }} = u_parabolic{{ n }}[3].w * u_parabolic{{ n }}[3].w;
         {% endfor %}

         {% for n in range(0, numCompoundParabolic) %}
         float comp0r2{{ n }} = u_compoundParabolic{{ n }}[0].w * u_compoundParabolic{{ n }}[0].w;
         float comp1r2{{ n }} = u_compoundParabolic{{ n }}[1].w * u_compoundParabolic{{ n }}[1].w;
         {% endfor %}

         {% for n in range(0, numCompoundLoxodromic) %}
         float loxoInnerR2{{ n }} = u_compoundLoxodromic{{ n }}[0].w * u_compoundLoxodromic{{ n }}[0].w;
         float loxoOuterR2{{ n }} = u_compoundLoxodromic{{ n }}[1].w * u_compoundLoxodromic{{ n }}[1].w;
         float loxoS3R2{{ n }} = u_compoundLoxodromic{{ n }}[3].w * u_compoundLoxodromic{{ n }}[3].w;
         float loxoS4R2{{ n }} = u_compoundLoxodromic{{ n }}[4].w * u_compoundLoxodromic{{ n }}[4].w;
         {% endfor %}

         const int MAX_KLEIN_ITARATION = 30;
         float distKlein(vec3 pos){
             loopNum = 0.;
             float dr = 1.;
             bool loopEnd = true;

             for(int i = 0 ; i < MAX_KLEIN_ITARATION ; i++){
                 if(i >= u_numIterations) break;
                 loopEnd = true;
                 {% for n in range(0, numCompoundParabolic) %}
                 if(distance(pos, u_compoundParabolic{{ n }}[0].xyz) < u_compoundParabolic{{ n }}[0].w){
                     vec3 diff0 = (pos - u_compoundParabolic{{ n }}[0].xyz);
                     dr *= comp0r2{{ n }} / dot(diff0, diff0);
                     pos = sphereInvert(pos, u_compoundParabolic{{ n }}[0].xyz, comp0r2{{ n }});

                     vec3 diff1 = (pos - u_compoundParabolic{{ n }}[1].xyz);
                     dr *= comp1r2{{ n }} / dot(diff1, diff1);
                     pos = sphereInvert(pos, u_compoundParabolic{{ n }}[1].xyz, comp1r2{{ n }});

                     pos = u_compoundRotateMat3{{ n }} *  pos;

                     loopEnd = false;
                     loopNum++;
                 }else if(distance(pos, u_compoundParabolic{{ n }}[2].xyz) >= u_compoundParabolic{{ n }}[2].w){
                     vec3 diff1 = (pos - u_compoundParabolic{{ n }}[1].xyz);
                     dr *= comp1r2{{ n }} / dot(diff1, diff1);
                     pos = sphereInvert(pos, u_compoundParabolic{{ n }}[1].xyz,
                                        comp1r2{{ n }});

                     vec3 diff0 = (pos - u_compoundParabolic{{ n }}[0].xyz);
                     dr *= comp0r2{{ n }} / dot(diff0, diff0);
                     pos = sphereInvert(pos, u_compoundParabolic{{ n }}[0].xyz, comp0r2{{ n }});

                     pos = u_invCompoundRotateMat3{{ n }} * pos;

                     loopEnd = false;
                     loopNum++;
                 }

                 {% endfor %}

                 {% for n in range(0,  numTransformBySpheres ) %}
                 if(distance(pos, u_transformBySpheres{{ n }}[0].xyz) < u_transformBySpheres{{ n }}[0].w){
                     vec3 diff0 = (pos - u_transformBySpheres{{ n }}[0].xyz);
                     dr *= s0r2{{ n }} / dot(diff0, diff0);
                     pos = sphereInvert(pos, u_transformBySpheres{{ n }}[0].xyz, s0r2{{ n }});

                     vec3 diff1 = (pos - u_transformBySpheres{{ n }}[1].xyz);
                     dr *= s1r2{{ n }} / dot(diff1, diff1);
                     pos = sphereInvert(pos, u_transformBySpheres{{ n }}[1].xyz, s1r2{{ n }});

                     loopEnd = false;
                     loopNum++;
                 }else if(distance(pos, u_transformBySpheres{{ n }}[2].xyz) >= u_transformBySpheres{{ n }}[2].w){
                     vec3 diff1 = (pos - u_transformBySpheres{{ n }}[1].xyz);
                     dr *= s1r2{{ n }} / dot(diff1, diff1);
                     pos = sphereInvert(pos, u_transformBySpheres{{ n }}[1].xyz,
                                        s1r2{{ n }});

                     vec3 diff0 = (pos - u_transformBySpheres{{ n }}[0].xyz);
                     dr *= s0r2{{ n }} / dot(diff0, diff0);
                     pos = sphereInvert(pos, u_transformBySpheres{{ n }}[0].xyz, s0r2{{ n }});

                     loopEnd = false;
                     loopNum++;
                 }
                 {% endfor %}

                 {% if numSchottkySpheres > 2 %}
                 {% for n  in range(0,  numSchottkySpheres ) %}
                 {% if n == 0 %}
                 if(distance(pos, u_schottkySphere0.xyz) < u_schottkySphere0.w){
                     vec3 diff = (pos - u_schottkySphere0.xyz);
                     dr *= u_schottkySphere0r2 / dot(diff, diff);
                     pos = sphereInvert(pos, u_schottkySphere0.xyz, u_schottkySphere0r2);
                     loopEnd = false;
                     loopNum++;
                 }
                 {% else %}
                 else if(distance(pos, u_schottkySphere{{ n }}.xyz) < u_schottkySphere{{ n }}.w){
                     vec3 diff = (pos - u_schottkySphere{{ n }}.xyz);
                     dr *= u_schottkySphere{{ n }}r2 / dot(diff, diff);
                     pos = sphereInvert(pos, u_schottkySphere{{ n }}.xyz,
                                        u_schottkySphere{{ n }}r2);
                     loopEnd = false;
                     loopNum++;
                 }
                 {% endif %}
                 {% endfor %}
                 {% elif numSchottkySpheres == 2 %}
                 if(distance(pos, u_schottkySphere0.xyz) < u_schottkySphere0.w){
                     vec3 diff = (pos - u_schottkySphere0.xyz);
                     dr *= u_schottkySphere0r2 / dot(diff, diff);
                     pos = sphereInvert(pos, u_schottkySphere0.xyz,
                                        u_schottkySphere0r2);
                     loopEnd = false;
                     loopNum++;
                 }else if(distance(pos, u_schottkySphere1.xyz) < u_schottkySphere1.w){
                     vec3 diff = (pos - u_schottkySphere1.xyz);
                     dr *= u_schottkySphere1r2 / dot(diff, diff);
                     pos = sphereInvert(pos, u_schottkySphere1.xyz, u_schottkySphere1r2);
                     loopEnd = false;
                     loopNum++;
                 }
                 {% elif numSchottkySpheres == 1 %}
                 if(distance(pos, u_schottkySphere0.xyz) < u_schottkySphere0.w){
                     vec3 diff = (pos - u_schottkySphere0.xyz);
                     dr *= u_schottkySphere0r2 / dot(diff, diff);
                     pos = sphereInvert(pos, u_schottkySphere0.xyz, u_schottkySphere0r2);
                     loopEnd = false;
                     loopNum++;
                 }
                 {% endif %}

                 {% for n in range(0,  numInfiniteSpheres ) %}
                 pos -= u_infiniteSphere{{ n }}.xyz;
                 pos = u_invRotateInfiniteSphereMat3{{ n }} * pos;
                 if(pos.z > 0.){
                     pos.z *= -1.;
                     loopEnd = false;
                     loopNum++;
                 }
                 pos = u_rotateInfiniteSphereMat3{{ n }} * pos;
                 pos += u_infiniteSphere{{ n }}.xyz;

                 {% endfor %}


                 {% for n in range(0,  numTransformByPlanes ) %}
                 pos -= vec3(u_transformByPlanes{{ n }}[0], u_transformByPlanes{{ n }}[1], u_transformByPlanes{{ n }}[2]);
                 pos = u_invRotatePlaneMat3{{ n }} * pos;
                 if(pos.z < u_transformByPlanes{{ n }}[3] || u_transformByPlanes{{ n }}[4] < pos.z){
                     pos.z -= u_transformByPlanes{{ n }}[3];
                     float nn = floor(pos.z / (u_transformByPlanes{{n}}[4] - u_transformByPlanes{{ n }}[3]));
                     pos.z = mod(pos.z,
                                 u_transformByPlanes{{ n }}[4] - u_transformByPlanes{{ n }}[3]);
                     pos.z += u_transformByPlanes{{ n }}[3];
                     float theta = -radians(u_transformByPlanes{{ n }}[8]) * nn;
                     float cosTheta = cos(theta);
                     float sinTheta = sin(theta);
                     mat3 m = mat3(cosTheta, -sinTheta, 0,
                                   sinTheta, cosTheta, 0,
                                   0, 0, 1);
                     pos = m * pos;

                     loopEnd = false;
                     loopNum ++;
                 }
                 pos = u_rotatePlaneMat3{{ n }} * pos;
                 pos += vec3(u_transformByPlanes{{ n }}[0], u_transformByPlanes{{ n }}[1], u_transformByPlanes{{ n }}[2]);
                 {% endfor %}
                 {% for n in range(0, numCompoundLoxodromic) %}
                 if(distance(pos, u_compoundLoxodromic{{ n }}[0].xyz) < u_compoundLoxodromic{{ n }}[0].w){
                     vec3 diff4 = (pos - u_compoundLoxodromic{{ n }}[4].xyz);
                     dr *= loxoS4R2{{ n }} / dot(diff4, diff4);
                     pos = sphereInvert(pos, u_compoundLoxodromic{{ n }}[4].xyz, loxoS4R2{{ n }});

                     vec3 diff3 = (pos - u_compoundLoxodromic{{ n }}[3].xyz);
                     dr *= loxoS3R2{{ n }} / dot(diff3, diff3);
                     pos = sphereInvert(pos, u_compoundLoxodromic{{ n }}[3].xyz, loxoS3R2{{ n }});

                     vec3 diff0 = (pos - u_compoundLoxodromic{{ n }}[0].xyz);
                     dr *= loxoInnerR2{{ n }} / dot(diff0, diff0);
                     pos = sphereInvert(pos, u_compoundLoxodromic{{ n }}[0].xyz, loxoInnerR2{{ n }});

                     vec3 diff1 = (pos - u_compoundLoxodromic{{ n }}[1].xyz);
                     dr *= loxoOuterR2{{ n }} / dot(diff1, diff1);
                     pos = sphereInvert(pos, u_compoundLoxodromic{{ n }}[1].xyz, loxoOuterR2{{ n }});

                     loopEnd = false;
                     loopNum++;
                 }else if(distance(pos, u_compoundLoxodromic{{ n }}[2].xyz) >= u_compoundLoxodromic{{ n }}[2].w){
                     vec3 diff1 = (pos - u_compoundLoxodromic{{ n }}[1].xyz);
                     dr *= loxoOuterR2{{ n }} / dot(diff1, diff1);
                     pos = sphereInvert(pos, u_compoundLoxodromic{{ n }}[1].xyz,
                                        loxoOuterR2{{ n }});

                     vec3 diff0 = (pos - u_compoundLoxodromic{{ n }}[0].xyz);
                     dr *= loxoInnerR2{{ n }} / dot(diff0, diff0);
                     pos = sphereInvert(pos, u_compoundLoxodromic{{ n }}[0].xyz, loxoInnerR2{{ n }});

                     vec3 diff3 = (pos - u_compoundLoxodromic{{ n }}[3].xyz);
                     dr *= loxoS3R2{{ n }} / dot(diff3, diff3);
                     pos = sphereInvert(pos, u_compoundLoxodromic{{ n }}[3].xyz, loxoS3R2{{ n }});

                     vec3 diff4 = (pos - u_compoundLoxodromic{{ n }}[4].xyz);
                     dr *= loxoS4R2{{ n }} / dot(diff4, diff4);
                     pos = sphereInvert(pos, u_compoundLoxodromic{{ n }}[4].xyz, loxoS4R2{{ n }});

                     loopEnd = false;
                     loopNum++;
                 }
                 {% endfor %}

                 {% for n in range(0, numParabolic) %}
                 vec3 diffFiexed{{ n }} = pos - u_parabolic{{ n }}[3].xyz;
                 dr *= pFixedR2{{ n }} / dot(diffFiexed{{ n }}, diffFiexed{{ n }});
                 pos = sphereInvert(pos, u_parabolic{{ n }}[3].xyz, u_parabolic{{ n }}[3].w * u_parabolic{{ n }}[3].w);
                 pos -= u_parabolic{{ n }}[5].xyz;
                 pos = u_parabolicRotationMat{{ n }}[1] * pos;
                 if(pos.z < 0. || u_parabolic{{ n }}[5].w < pos.z){
                     pos.z = mod(pos.z, u_parabolic{{ n }}[5].w);
                     loopEnd = false;
                 }
                 pos = u_parabolicRotationMat{{ n }}[0] * pos;
                 pos += u_parabolic{{ n }}[5].xyz;
                 diffFiexed{{ n }} = pos - u_parabolic{{ n }}[3].xyz;
                 dr *= pFixedR2{{ n }} / dot(diffFiexed{{ n }}, diffFiexed{{ n }});
                 pos = sphereInvert(pos, u_parabolic{{ n }}[3].xyz, u_parabolic{{ n }}[3].w * u_parabolic{{ n }}[3].w);

                 if(distance(pos, u_parabolic{{ n }}[0].xyz) < u_parabolic{{ n }}[0].w){
                     vec3 diff0 = (pos - u_parabolic{{ n }}[0].xyz);
                     dr *= p0r2{{ n }} / dot(diff0, diff0);
                     pos = sphereInvert(pos, u_parabolic{{ n }}[0].xyz, p0r2{{ n }});

                     vec3 diff1 = (pos - u_parabolic{{ n }}[1].xyz);
                     dr *= p1r2{{ n }} / dot(diff1, diff1);
                     pos = sphereInvert(pos, u_parabolic{{ n }}[1].xyz, p1r2{{ n }});

                     loopEnd = false;
                     loopNum++;
                 }else if(distance(pos, u_parabolic{{ n }}[2].xyz) >= u_parabolic{{ n }}[2].w){
                     vec3 diff1 = (pos - u_parabolic{{ n }}[1].xyz);
                     dr *= p1r2{{ n }} / dot(diff1, diff1);
                     pos = sphereInvert(pos, u_parabolic{{ n }}[1].xyz,
                                        p1r2{{ n }});

                     vec3 diff0 = (pos - u_parabolic{{ n }}[0].xyz);
                     dr *= p0r2{{ n }} / dot(diff0, diff0);
                     pos = sphereInvert(pos, u_parabolic{{ n }}[0].xyz, p0r2{{ n }});

                     loopEnd = false;
                     loopNum++;
                 }
                 {% endfor %}

                 if(loopEnd == true) break;
             }
             {% if numBaseSpheres == 1 %}
             return (distance(pos, u_baseSphere0.xyz) - u_baseSphere0.w) / abs(dr) * 0.08;
             {% elif numBaseSpheres > 1 %}
             float minDist = (distance(pos, u_baseSphere0.xyz) - u_baseSphere0.w) / abs(dr) * 0.08;
             {% for n  in range(1,  numBaseSpheres ) %}
             minDist = min(minDist,
                           (distance(pos, u_baseSphere{{ n }}.xyz) - u_baseSphere{{ n }}.w) / abs(dr) * 0.08);
             {% endfor %}
             return minDist;
             {% else %}
             return NO_HIT;
             {% endif %}
         }
        </script>
        <script id="3dOrbitTemplate" type="x-shader/x-fragment">
         precision mediump float;

         {% include uniformVariables %}

         {% include constants %}

         // from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/
         vec2 rand2n(vec2 co, int sampleIndex) {
             vec2 seed = co * (float(sampleIndex) + 1.0);
             seed+=vec2(-1,1);
             // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html
             return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),
                         fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));
         }

         {% include intersectFunctions %}

         vec3 sphereInvert(const vec3 pos, const vec3 spherePos, const float sphereR2){
             return ((pos - spherePos) * sphereR2)/(distance(pos, spherePos) * distance(pos, spherePos) ) + spherePos;
         }

         float loopNum = 0.;
         {% include distKlein %}

         vec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,
                                                                               const float width, const float height, const vec2 coord){
             float imagePlane = (height * .5) / tan(radians(fov) * .5);
             vec3 v = normalize(target - eye);
             vec3 xaxis = normalize(cross(v, up));
             vec3 yaxis =  normalize(cross(v, xaxis));
             vec3 center = v * imagePlane;
             vec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));
             return normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));
         }

         const vec4 K = vec4(1.0, .666666, .333333, 3.0);
         vec3 hsv2rgb(const vec3 c){
             vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
             return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
         }

         float distFunc(vec3 p){
             return distKlein(p);
         }

         const vec2 d = vec2(0.01, 0.);
         vec3 getNormal(const vec3 p){
             return normalize(vec3(distFunc(p + d.xyy) - distFunc(p - d.xyy),
                                   distFunc(p + d.yxy) - distFunc(p - d.yxy),
                                   distFunc(p + d.yyx) - distFunc(p - d.yyx)));
         }

         const vec3 LIGHT_DIR = normalize(vec3(0.0, 1., 0.5));
         const int MAX_MARCHING_LOOP = 800;
         vec4 march(int objId, int objIndex, int objComponentId, int mtl,
                    const vec3 origin, const  vec3 ray,
                                              const float threshold, vec4 isect){
             vec3 rayPos = origin;
             float dist;
             float rayLength = 0.;
             for(int i = 0 ; i < MAX_MARCHING_LOOP ; i++){
                 dist = distFunc(rayPos);
                 rayLength += dist;
                 rayPos = origin + ray * rayLength ;
                 if(dist < threshold) break;
             }
             if(dist < EPSILON && rayLength < isect.x){
                 g_objId = objId;
                 g_objIndex = objIndex;
                 g_objComponentId = objComponentId;
                 g_mtl = mtl;
                 g_isHit = true;
                 return vec4(rayLength);
             }else{
                 return isect;
             }
         }

         const int MAX_TRACE_DEPTH = 5;

         float transparency = 0.8;
         vec3 calcColor(vec3 eye, vec3 ray){
             vec3 l = BLACK;
             float coeff = 1.;
             for (int depth = 0 ; depth < MAX_TRACE_DEPTH ; depth++){
                 vec4 result = vec4(NO_HIT);

                 {% if numBaseSpheres >= 1 %}
                 result = march(ID_KLEIN_ORBIT, 0, 0, MTL_DIFFUSE,
                                eye, ray, 0.01, result);
                 {% endif %}

                 if(u_displayGenerators){

                     {% for n  in range(0,  numSchottkySpheres ) %}
                     result = intersectSphere(ID_SCHOTTKY_SPHERE, {{ n }}, 0, MTL_TRANSPARENT,
                                              u_schottkySphere{{ n }}.xyz, u_schottkySphere{{ n }}.w,
                                              eye, ray, result);
                     {% endfor %}

                     {% for n in range(0,  numBaseSpheres ) %}
                     result = intersectSphere(ID_BASE_SPHERE, {{ n }}, 0, MTL_TRANSPARENT,
                                              u_baseSphere{{ n }}.xyz, u_baseSphere{{ n }}.w,
                                              eye, ray, result);
                     {% endfor %}

                     {% for n in range(0,  numInfiniteSpheres ) %}
                     result = intersectInfiniteSphere(ID_INFINITE_SPHERE, {{ n }}, 0, MTL_DIFFUSE,
                                                      u_infiniteSphere{{ n }}.xyz,
                                                      u_infiniteSphere{{ n }}.w,
                                                      u_rotateInfiniteSphereMat3{{ n }},
                                                      eye, ray, result);
                     {% endfor %}

                     {% for n in range(0,  numTransformByPlanes ) %}
                     result = intersectParallelPlanes(ID_TRANSFORM_BY_PLANES, {{ n }}, MTL_DIFFUSE,
                                                      vec3(u_transformByPlanes{{ n }}[0],
                                                           u_transformByPlanes{{ n }}[1],
                                                           u_transformByPlanes{{ n }}[2]),
                                                      u_transformByPlanes{{ n }}[3],
                                                      u_transformByPlanes{{ n }}[4],
                                                      u_transformByPlanes{{ n }}[5],
                                                      u_rotatePlaneMat3{{ n }},
                                                      u_transformByPlanes{{ n }}[8],
                                                      eye, ray, result);
                     {% endfor %}

                     {% for n in range(0, numParabolic) %}
                     result = intersectSphere(ID_PARABOLIC, {{ n }}, 0, MTL_TRANSPARENT,
                                              u_parabolic{{ n }}[0].xyz,
                                              u_parabolic{{ n }}[0].w,
                                              eye, ray, result);
                     result = intersectSphere(ID_PARABOLIC, {{ n }}, 1, MTL_TRANSPARENT,
                                              u_parabolic{{ n }}[1].xyz,
                                              u_parabolic{{ n }}[1].w,
                                              eye, ray, result);
                     result = intersectSphere(ID_PARABOLIC, {{ n }}, 2, MTL_TRANSPARENT,
                                              u_parabolic{{ n }}[2].xyz,
                                              u_parabolic{{ n }}[2].w,
                                              eye, ray, result);
                     {% endfor %}

                     {% for n in range(0, numTransformBySpheres) %}
                     result = intersectSphere(ID_TRANSFORM_BY_SPHERES, {{ n }}, 0, MTL_TRANSPARENT,
                                              u_transformBySpheres{{ n }}[0].xyz,
                                              u_transformBySpheres{{ n }}[0].w,
                                              eye, ray, result);
                     result = intersectSphere(ID_TRANSFORM_BY_SPHERES, {{ n }}, 1, MTL_TRANSPARENT,
                                              u_transformBySpheres{{ n }}[1].xyz,
                                              u_transformBySpheres{{ n }}[1].w,
                                              eye, ray, result);
                     result = intersectSphere(ID_TRANSFORM_BY_SPHERES, {{ n }}, 2, MTL_TRANSPARENT,
                                              u_transformBySpheres{{ n }}[2].xyz,
                                              u_transformBySpheres{{ n }}[2].w,
                                              eye, ray, result);
                     {% endfor %}

                     {% for n in range(0, numCompoundParabolic) %}
                     result = intersectSphere(ID_COMPOUND_PARABOLIC, {{ n }}, 0, MTL_TRANSPARENT,
                                              u_compoundParabolic{{ n }}[0].xyz,
                                              u_compoundParabolic{{ n }}[0].w,
                                              eye, ray, result);
                     result = intersectSphere(ID_COMPOUND_PARABOLIC, {{ n }}, 1, MTL_TRANSPARENT,
                                              u_compoundParabolic{{ n }}[1].xyz,
                                              u_compoundParabolic{{ n }}[1].w,
                                              eye, ray, result);
                     result = intersectSphere(ID_COMPOUND_PARABOLIC, {{ n }}, 2, MTL_TRANSPARENT,
                                              u_compoundParabolic{{ n }}[2].xyz,
                                              u_compoundParabolic{{ n }}[2].w,
                                              eye, ray, result);
                     {% endfor %}

                     {% for n in range(0, numCompoundLoxodromic) %}
                     result = intersectSphere(ID_COMPOUND_LOXODROMIC, {{ n }}, 0, MTL_TRANSPARENT,
                                              u_compoundLoxodromic{{ n }}[0].xyz,
                                              u_compoundLoxodromic{{ n }}[0].w,
                                              eye, ray, result);
                     result = intersectSphere(ID_COMPOUND_LOXODROMIC, {{ n }}, 1, MTL_TRANSPARENT,
                                              u_compoundLoxodromic{{ n }}[1].xyz,
                                              u_compoundLoxodromic{{ n }}[1].w,
                                              eye, ray, result);
                     result = intersectSphere(ID_COMPOUND_LOXODROMIC, {{ n }}, 2, MTL_TRANSPARENT,
                                              u_compoundLoxodromic{{ n }}[2].xyz,
                                              u_compoundLoxodromic{{ n }}[2].w,
                                              eye, ray, result);
                     result = intersectSphere(ID_COMPOUND_LOXODROMIC, {{ n }}, 3, MTL_TRANSPARENT,
                                              u_compoundLoxodromic{{ n }}[3].xyz,
                                              u_compoundLoxodromic{{ n }}[3].w,
                                              eye, ray, result);
                     result = intersectSphere(ID_COMPOUND_LOXODROMIC, {{ n }}, 4, MTL_TRANSPARENT,
                                              u_compoundLoxodromic{{ n }}[4].xyz,
                                              u_compoundLoxodromic{{ n }}[4].w,
                                              eye, ray, result);
                     result = intersectSphere(ID_COMPOUND_LOXODROMIC, {{ n }}, 5, MTL_TRANSPARENT,
                                              u_compoundLoxodromic{{ n }}[5].xyz,
                                              50.,
                                              eye, ray, result);
                     result = intersectSphere(ID_COMPOUND_LOXODROMIC, {{ n }}, 6, MTL_TRANSPARENT,
                                              u_compoundLoxodromic{{ n }}[6].xyz,
                                              50.,
                                              eye, ray, result);
                     result = intersectSphere(ID_COMPOUND_LOXODROMIC, {{ n }}, 7, MTL_TRANSPARENT,
                                              u_compoundLoxodromic{{ n }}[7].xyz,
                                              50.,
                                              eye, ray, result);
                     {% endfor %}

                 }

                 if(result.x != NO_HIT){
                     vec3 normal = result.yzw;
                     vec3 intersection = eye + ray * result.x;

                     vec3 matColor = LIGHT_GRAY;
                     if( g_objId == ID_SCHOTTKY_SPHERE){
                         g_mtl = MTL_TRANSPARENT;
                         matColor = (g_objIndex == u_selectedObjectIndex &&
                                     g_objId == u_selectedObjectId) ? RED : LIGHT_GRAY;
                     }else if(g_objId == ID_BASE_SPHERE){
                         matColor = (g_objId == u_selectedObjectId &&
                                     g_objIndex == u_selectedObjectIndex) ? RED : GREEN;
                     }else if(g_objId == ID_INFINITE_SPHERE){
                         matColor = (g_objId == u_selectedObjectId &&
                                     g_objIndex == u_selectedObjectIndex) ? RED : BLUE;
                     }else if(g_objId == ID_AXIS_CYLINDER){
                         matColor = (g_objComponentId == u_selectedAxis) ? RED : LIGHT_GRAY;
                     }else if(g_objId == ID_TRANSFORM_BY_PLANES){
                         matColor = (g_objId == u_selectedObjectId &&
                                     g_objIndex == u_selectedObjectIndex)?
                                    RED : BLUE;
                     }else if(g_objId == ID_TRANSFORM_BY_SPHERES){
                         matColor = (g_objComponentId == 0) ? LIGHT_BLUE : vec3(0.2, 0.2, 0.9);
                         matColor = (g_objComponentId == 1) ? YELLOW : matColor;
                         matColor = (g_objId == u_selectedObjectId &&
                                     g_objIndex == u_selectedObjectIndex &&
                                     g_objComponentId == u_selectedComponentId) ? RED : matColor;
                     }else if(g_objId == ID_COMPOUND_PARABOLIC){
                         matColor = (g_objComponentId == 0) ? LIGHT_BLUE : vec3(0.2, 0.2, 0.9);
                         matColor = (g_objComponentId == 1) ? YELLOW : matColor;
                         matColor = (g_objId == u_selectedObjectId &&
                                     g_objIndex == u_selectedObjectIndex &&
                                     g_objComponentId == u_selectedComponentId) ? RED : matColor;
                     }else if(g_objId == ID_COMPOUND_LOXODROMIC){
                         matColor = (g_objComponentId == 0) ? LIGHT_BLUE : vec3(0.2, 0.2, 0.9);
                         matColor = (g_objComponentId == 1) ? YELLOW : matColor;
                         matColor = (g_objComponentId == 3) ? PINK : matColor;
                         matColor = (g_objComponentId == 4) ? GREEN : matColor;
                         matColor = (g_objComponentId == 5) ? BLUE : matColor;
                         matColor = (g_objComponentId == 6) ? LIGHT_GRAY : matColor;
                         matColor = (g_objComponentId == 7) ? LIGHT_GRAY : matColor;
                     }else if(g_objId == ID_KLEIN_ORBIT){
                         matColor = hsv2rgb(vec3(0.1 + loopNum * 0.1 , 1., 1.));
                         normal = getNormal(intersection);
                     }else if(g_objId == ID_PARABOLIC){
                         matColor = (g_objComponentId == 0) ? LIGHT_BLUE : vec3(0.2, 0.2, 0.9);
                         matColor = (g_objComponentId == 1) ? YELLOW : matColor;
                         matColor = (g_objId == u_selectedObjectId &&
                                     g_objIndex == u_selectedObjectIndex &&
                                     g_objComponentId == u_selectedComponentId) ? RED : matColor;
                     }

                     // diffuse lighting by directionalLight
                     vec3 diffuse =  clamp(dot(normal, LIGHT_DIR), 0., 1.) * matColor;
                     vec3 ambient = matColor * AMBIENT_FACTOR;
                     if(g_mtl == MTL_TRANSPARENT){
                         coeff *= transparency;
                         l += (diffuse + ambient) * coeff;
                         eye = intersection + ray * 0.01;
                         continue;
                     }else{
                         l += (diffuse + ambient) * coeff;
                     }
                 }
                 break;
             }
             return l;
         }

         const float SAMPLE_NUM = 1.;
         void main(){
             //  const vec2 coordOffset = vec2(0.5);
             vec2 coordOffset = rand2n(gl_FragCoord.xy, u_numSamples);
             vec3 ray = calcRay(u_camera[0], u_camera[1], u_camera[2], u_camera[3].x,
                                u_iResolution.x, u_iResolution.y,
                                gl_FragCoord.xy + coordOffset);

             vec3 texCol = texture2D(u_accTexture, gl_FragCoord.xy / u_iResolution).rgb;
             gl_FragColor = vec4(mix(calcColor(u_camera[0], ray), texCol,
                                     u_textureWeight), 1.0);
         }
        </script>
        <script id="3dOrbitPathTraceTemplate" type="x-shader/x-fragment">
         precision mediump float;

         {% include uniformVariables %}

         {% include constants %}

         int g_mtl = -1;
         int g_objId = -1;
         int g_objIndex = -1;
         int g_objComponentId = -1;
         bool g_isHit = false;

         //------------------------------------------------------------------
         // random functions based on Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/
         int g_numRandCall = 0;
         vec2 rand2n(vec2 co, int numSamples) {
             vec2 seed = co * (float(numSamples + g_numRandCall) + 1.0);
             g_numRandCall++;
             seed+=vec2(-1,1);
             // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html
             return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),
                         fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));
         }

         vec3 ortho(vec3 v) {
             //  See : http://lolengine.net/blog/2013/09/21/picking-orthogonal-vector-combing-coconuts
             return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);
         }

         vec3 getSampleBiased(vec3  dir, float power) {
             dir = normalize(dir);
             vec3 o1 = normalize(ortho(dir));
             vec3 o2 = normalize(cross(dir, o1));
             vec2 r = rand2n(gl_FragCoord.xy, u_numSamples);
             r.x=r.x*2.*PI;
             r.y=pow(r.y,1.0/(power+1.0));
             float oneminus = sqrt(1.0-r.y*r.y);
             return cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;
         }

         vec3 getSample(vec3 dir) {
             return getSampleBiased(dir,0.0); // <- unbiased!
         }

         vec3 getCosineWeightedSample(vec3 dir) {
             return getSampleBiased(dir,1.0);
         }

         //------------------------------------------------------------------

         vec3 sphereInvert(const vec3 pos, const vec3 spherePos, const float sphereR2){
             return ((pos - spherePos) * sphereR2)/(distance(pos, spherePos) * distance(pos, spherePos) ) + spherePos;
         }

         float loopNum = 0.;
         {% include distKlein %}

         vec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,
                                                                               const float width, const float height, const vec2 coord){
             float imagePlane = (height * .5) / tan(radians(fov) * .5);
             vec3 v = normalize(target - eye);
             vec3 xaxis = normalize(cross(v, up));
             vec3 yaxis =  normalize(cross(v, xaxis));
             vec3 center = v * imagePlane;
             vec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));
             return normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));
         }

         const vec4 K = vec4(1.0, .666666, .333333, 3.0);
         vec3 hsv2rgb(const vec3 c){
             vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
             return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
         }

         float distFunc(vec3 p){
             return distKlein(p);
         }

         const vec2 d = vec2(0.01, 0.);
         vec3 getNormal(const vec3 p){
             return normalize(vec3(distFunc(p + d.xyy) - distFunc(p - d.xyy),
                                   distFunc(p + d.yxy) - distFunc(p - d.yxy),
                                   distFunc(p + d.yyx) - distFunc(p - d.yyx)));
         }

         const int MAX_MARCHING_LOOP = 800;
         vec4 march(int objId, int objIndex, int objComponentId, int mtl,
                    const vec3 origin, const  vec3 ray,
                                              const float threshold, vec4 isect){
             vec3 rayPos = origin;
             float dist;
             float rayLength = 0.;
             for(int i = 0 ; i < MAX_MARCHING_LOOP ; i++){
                 dist = distFunc(rayPos);
                 rayLength += dist;
                 rayPos = origin + ray * rayLength ;
                 if(dist < threshold) break;
             }
             if(dist < EPSILON && rayLength < isect.x){
                 g_objId = objId;
                 g_objIndex = objIndex;
                 g_objComponentId = objComponentId;
                 g_mtl = mtl;
                 g_isHit = true;
                 return vec4(rayLength);
             }else{
                 return isect;
             }
         }

         const int MAX_TRACE_DEPTH = 3;

         vec3 skyColor(vec3 dir){
             return WHITE;
         }

         vec3 calcColor(vec3 eye, vec3 ray){
             vec3 l = WHITE;
             for (int depth = 0 ; depth < 999999 ; depth++){
                 if(depth > MAX_TRACE_DEPTH) break;
                 vec4 result = vec4(NO_HIT);

                 {% if numBaseSpheres >= 1 %}
                 result = march(ID_KLEIN_ORBIT, 0, 0, MTL_DIFFUSE,
                                eye, ray, 0.001, result);
                 {% endif %}

                 if(result.x != NO_HIT){
                     vec3 normal = result.yzw;
                     vec3 intersection = eye + ray * result.x;

                     vec3 matColor = WHITE;
                     if(g_objId == ID_KLEIN_ORBIT){
                         matColor = hsv2rgb(vec3(0.1 + loopNum * 0.1 , 1., 1.));
                         normal = getNormal(intersection);
                     }

                     //diffuse materials reflectivity
                     const float albedo = 1.0;
                     //vec3 r = getSample(normal);
                     //l *= matColor * (2. * albedo * dot(normal, r));
                     vec3 r = getCosineWeightedSample(normal);
                     l *= matColor * albedo;
                     eye = intersection + normal * 0.001 * 2.;
                     ray = r;
                 }else{
                     return l * skyColor( ray );
                 }
             }
             return BLACK;
         }

         void main(){
             vec2 coordOffset = rand2n(gl_FragCoord.xy, u_numSamples);
             vec3 ray = calcRay(u_camera[0], u_camera[1], u_camera[2], u_camera[3].x,
                                u_iResolution.x, u_iResolution.y,
                                gl_FragCoord.xy + coordOffset);

             vec3 texCol = texture2D(u_accTexture, gl_FragCoord.xy / u_iResolution).rgb;
             gl_FragColor = vec4(mix(calcColor(u_camera[0], ray), texCol,
                                     u_textureWeight), 1.0);
         }
        </script>
    </head>
    <body id="bodyElem">
        <header class="header">
            <ul class="headerLeft">
                <li class="myBtn"><a class="btnLink" href="../index.html">SchottkyLink</a></li>
                <li class="myBtn"><a class="btnLink" href="../2d/index.html">2D</a></li>
                <li class="myBtn"><a class="btnLink" href="./index.html">3D</a></li>
            </ul>
            <ul class="headerRight">
                <li class="headerButton"><ui-button text="Usage" type="flat" raised color="primary" @click="switchInstructionModal"></ui-button></li>
                <li class="headerButton"><ui-button type="flat" raised color="primary" text="Save Scene" @click="saveScene"></ui-button></li>
                <li class="headerButton"><ui-button type="flat" raised color="primary" text="Load Scene" @click="loadScene"></ui-button></li>
                <li class="headerButton"><ui-button type="flat" raised color="primary" text="Load Preset"
                                                    open-dropdown-on="hover" :menu-options="presetList"
                                                    @menu-option-selected="presetSelected" has-dropdown-menu></ui-button></li>
            </ul>
        </header>
        <ui-modal id="modal1" :show.sync="orbitCanvas.isDisplayingInstruction">
            <div slot="header" class="ui-modal-header-text">
                Usage
            </div>
            <div class="ui-modal-body">
                <ul>
                    <li>Left Click: Select a generator</li>
                    <li>Right Click: Move on screen</li>
                    <li>Wheel Drag: Rotate camera</li>
                    <li>Wheel: Zoom</li>
                    <li>Double Left Click: Remove a generator</li>
                    <li>z + Drag : Move selected object along the x axis</li>
                    <li>x + Drag : Move selected object along the y axis</li>
                    <li>c + Drag : Move selected object along the z axis</li>
                    <li>s + Drag : Tweak radius of selected sphere</li>
                    <li>+ / - : Increase / Decrease maximum iterations</li>
                </ul>
            </div>
        </ui-modal>
        <div class="content">
            <div class="renderPanel">
                <div class="renderCanvasPanel" id="panel1">
                    <div id="canvasParent1" class="canvasParent">
                        <canvas id="schottkyCanvas" class="renderCanvas"></canvas>
                    </div>
                    <div class="renderPropertyPanel">
                        <ui-button text="save" raised @click="saveSchottkyImage">
                        </ui-button>
                    </div>
                </div>
                <div class="renderCanvasPanel" id="panel2">
                    <div id="canvasParent2" class="canvasParent">
                        <canvas id="orbitCanvas" class="renderCanvas"></canvas>
                    </div>
                    <div class="renderPropertyPanel">
                        <ui-button text="save" raised @click="saveOrbitImage">
                        </ui-button>
                        <div class="switchColumn">
                            <span>DisplayGen</span>
                            <ui-switch hide-label :value.sync="orbitCanvas.displayGenerators" @change="renderOrbit"></ui-switch>
                        </div>
                        <div class="switchColumn">
                            <span> Sampling  </span>
                            <ui-switch hide-label :value.sync="orbitCanvas.isSampling" @change="orbitSwitchSampling"></ui-switch>
                        </div>
                        <div class="switchColumn">
                            <span>GI</span>
                            <ui-switch hide-label @change="orbitSwitchGI"></ui-switch>
                        </div>
                        <div class="switchColumn">
                            <span>LowRes</span>
                            <ui-switch hide-label :value.sync="orbitCanvas.isRenderingLowResolution"></ui-switch>
                        </div>
                    </div>
                </div>
            </div>
            <div class="propertyPanel">
                <ui-tabs fullwidth>
                    <ui-tab header="Generator" id="tab-1">
                        <div class="imgBtn" @click="addBaseSphere">
                            <div class="row">
                                <img src="../img/baseSphere.png" width="128px" height="128px" />
                            </div>
                            <div class="row">
                                Base Sphere
                            </div>
                        </div>
                        <div class="imgBtn" @click="addSchottkySphere">
                            <div class="row">
                                <img src="../img/sphere.png" width="128px" height="128px" />
                            </div>
                            <div class="row">
                                Sphere
                            </div>
                        </div>
                        <div class="imgBtn" @click="addInfiniteSphere">
                            <div class="row">
                                <img src="../img/infiniteSphere.png" width="128px" height="128px" />
                            </div>
                            <div class="row">
                                Infinite Sphere
                            </div>
                        </div>
                        <div class="imgBtn" @click="addTranslation">
                            <div class="row">
                                <img src="../img/translation.png" width="128px" height="128px" />
                            </div>
                            <div class="row">
                                Translation
                            </div>
                        </div>
                        <div class="imgBtn" @click="addTransformBySpheres">
                            <div class="row">
                                <img src="../img/compositionSphere.png" width="128px" height="128px" />
                            </div>
                            <div class="row">
                                Composition
                            </div>
                        </div>
                        <div class="imgBtn" @click="addCompoundLoxodromic">
                            <div class="row">
                                <img src="../img/compoundLoxodromic.png" width="128px" height="128px" />
                            </div>
                            <div class="row">
                                Compound Loxodromic
                            </div>
                        </div>
                    </ui-tab>
                    <ui-tab header="Scene" id="tab-2">
                        <div class="row">
                            Pixel Density
                        </div>
                        <ui-select name="Pixel Density" :default="pixelDensitiesDefault"
                                   @selected="pixelDensitySelected" :options="pixelDensities">
                        </ui-select>
                        <ui-textbox name="iterations" type="number" :value.sync="orbitCanvas.numIterations"
                                    :min="minIterations" @changed="renderOrbit">

                        </ui-textbox>
                    </ui-tab>
                </ui-tabs>
            </div>
        </div>
        <footer class="footer">
            <a id="ghLink" href="https://github.com/soma-arc/SchottkyLink"
               target="_blank">
                <img src="../img/GitHub-Mark-32px.png" class="imgLink"/>
            </a>
            Created by soma_arc
        </footer>
    </body>
</html>
