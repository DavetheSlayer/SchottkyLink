<!DOCTYPE html>
<html><head>
    <title>SchottkyLink</title>
    <meta charset="UTF-8" />
    <style>
     body {
	 margin: 0;
     }
     canvas {
	 cursor: crosshair;
	 display: inline-block;
	 background-color: black;
     }
    </style>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="../lib/bootstrap.min.css" rel="stylesheet">
    <script type="text/javascript" src="../lib/nunjucks.min.js"></script>
    <script type="text/javascript" src="scripts/raytrace.js"></script>
    <script type="text/javascript" src="scripts/util.js"></script>
    <script type="text/javascript" src="scripts/geometry.js"></script>
    <script type="text/javascript" src="scripts/main.js"></script>
    <script id="vs" type="x-shader/x-vertex">
     attribute vec3 position;

     void main(void){
	 gl_Position = vec4(position, 1.0);
     }
    </script>

    <script id="3dSchottkyTemplate" type="x-shader/x-fragment">
     precision mediump float;
     uniform vec2 u_iResolution;
     uniform float u_iGlobalTime;
     uniform int u_selectedObjectId;
     uniform int u_selectedObjectIndex;
     uniform int u_selectedComponentId;
     uniform int u_selectedAxis;
     uniform vec3 u_eye;
     uniform vec3 u_up;
     uniform vec3 u_target;
     uniform float u_fov;
     {% for n in range(0,  numSchottkySpheres ) %}
     uniform vec4 u_schottkySphere{{ n }};
     {% endfor %}

     {% for n in range(0,  numBaseSpheres ) %}
     uniform vec4 u_baseSphere{{ n }};
     {% endfor %}

     {% for n in range(0,  numTransformByPlanes ) %}
     //[distToP1, distToP2, size, thetaRad, phiRad, twist]
     uniform float u_transformByPlanes{{ n }}[6];
     uniform mat3 u_rotatePlaneMat3{{ n }};
     uniform mat3 u_invRotatePlaneMat3{{ n }};
     uniform mat3 u_twistPlaneMat3{{ n }};
     uniform mat3 u_invTwistPlaneMat3{{ n }};
     {% endfor %}
     
     {% for n in range(0, numTransformBySpheres) %}
     //[innerSphere, outerSphere, invertedSphere]
     uniform vec4 u_transformBySpheres{{ n }}[3];
     {% endfor %}

     {% for n in range(0, numCompoundParabolic) %}
     //[innerSphere, outerSphere, invertedSphere]
     uniform vec4 u_compoundParabolic{{ n }}[3];
     {% endfor %}

     {% for n in range(0, numCompoundLoxodromic) %}
     uniform vec4 u_compoundLoxodromic{{ n }}[8];
     {% endfor %}

     // from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/
     vec2 rand2n(vec2 co, float sampleIndex) {
	 vec2 seed = co * (sampleIndex + 1.0);
	 seed+=vec2(-1,1);
	 // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html
	 return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),
                     fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));
     }

     const int ID_SCHOTTKY_SPHERE = 0;
     const int ID_BASE_SPHERE = 1;
     const int ID_TRANSFORM_BY_PLANES = 2;
     const int ID_TRANSFORM_BY_SPHERES = 3;
     const int ID_COMPOUND_PARABOLIC = 4;
     const int ID_COMPOUND_LOXODROMIC = 5;
     
     const int ID_AXIS_CYLINDER = 100;
     
     const float PI = 3.14159265359;
     const float PI_2 = PI/2.;
     const float EPSILON = 0.001;

     const int MTL_DIFFUSE = 0;
     const int MTL_TRANSPARENT = 1;
     int g_mtl = MTL_DIFFUSE;
     int g_objId = -1;
     int g_objIndex = -1;
     int g_objComponentId = -1;
     bool g_isHit = false;

     vec4 intersectSphere(int objId, int objIndex, int objComponentId, int mtl,
			  vec3 sphereCenter, float radius, 
			  vec3 rayOrigin, vec3 rayDir, vec4 isect){
	 g_isHit = false;
	 vec3 v = rayOrigin - sphereCenter;
	 float b = dot(rayDir, v);
	 float c = dot(v, v) - radius * radius;
	 float d = b * b - c;
	 if(d >= 0.){
             float s = sqrt(d);
             float t = -b - s;
             if(t <= EPSILON) t = -b + s;
             if(EPSILON < t && t < isect.x){
		 vec3 p = (rayOrigin + t * rayDir);
		 g_objId = objId;
		 g_objIndex = objIndex;
		 g_objComponentId = objComponentId;
		 g_mtl = mtl;
		 g_isHit = true;
		 return vec4(t, normalize(p - sphereCenter));
             }
	 }
	 return isect;
     }

     vec4 intersectXYCylinder(int objId, int objIndex, int objComponentId, int mtl,
			      float r, vec3 center,
			      vec3 rayOrigin, vec3 rayDir, vec4 isect){
	 g_isHit = false;
	 rayOrigin = rayOrigin - center;
	 float a = rayDir.x * rayDir.x + rayDir.y * rayDir.y;
	 float b = 2. * ( rayOrigin.x * rayDir.x + rayOrigin.y * rayDir.y);
	 float c = rayOrigin.x * rayOrigin.x + rayOrigin.y * rayOrigin.y - r * r;
	 float d = b * b - 4. * a * c;
	 if(d >= 0.){
	     float s = sqrt(d);
	     float t = (-b - s) / (2. * a);
             if(t <= EPSILON) t = (-b + s) / (2. * a);
             if(EPSILON < t && t < isect.x){
		 vec3 p = (rayOrigin + t * rayDir);
		 g_objId = objId;
		 g_objIndex = objIndex;
		 g_objComponentId = objComponentId;
		 g_mtl = mtl;
		 g_isHit = true;
		 return vec4(t, normalize(vec3(p.xy, 0)));
             }
	 }
	 return isect;
     }

     vec4 intersectYZCylinder(int objId, int objIndex, int objComponentId, int mtl,
			      float r, vec3 center,
			      vec3 rayOrigin, vec3 rayDir, vec4 isect){
	 g_isHit = false;
	 rayOrigin = rayOrigin - center;
	 float a = rayDir.z * rayDir.z + rayDir.y * rayDir.y;
	 float b = 2. * ( rayOrigin.z * rayDir.z + rayOrigin.y * rayDir.y);
	 float c = rayOrigin.z * rayOrigin.z + rayOrigin.y * rayOrigin.y - r * r;
	 float d = b * b - 4. * a * c;
	 if(d >= 0.){
	     float s = sqrt(d);
	     float t = (-b - s) / (2. * a);
             if(t <= EPSILON) t = (-b + s) / (2. * a);
             if(EPSILON < t && t < isect.x){
		 vec3 p = (rayOrigin + t * rayDir);
		 g_objId = objId;
		 g_objIndex = objIndex;
		 g_objComponentId = objComponentId;
		 g_mtl = mtl;
		 g_isHit = true;
		 return vec4(t, normalize(vec3(0, p.yz)));
             }
	 }
	 return isect;
     }

     vec4 intersectXZCylinder(int objId, int objIndex, int objComponentId, int mtl,
			      float r, vec3 center,
			      vec3 rayOrigin, vec3 rayDir, vec4 isect){
	 g_isHit = false;
	 rayOrigin = rayOrigin - center;
	 float a = rayDir.x * rayDir.x + rayDir.z * rayDir.z;
	 float b = 2. * ( rayOrigin.x * rayDir.x + rayOrigin.z * rayDir.z);
	 float c = rayOrigin.x * rayOrigin.x + rayOrigin.z * rayOrigin.z - r * r;
	 float d = b * b - 4. * a * c;
	 if(d >= 0.){
	     float s = sqrt(d);
	     float t = (-b - s) / (2. * a);
             if(t <= EPSILON) t = (-b + s) / (2. * a);
             if(EPSILON < t && t < isect.x){
		 vec3 p = (rayOrigin + t * rayDir);
		 g_objId = objId;
		 g_objIndex = objIndex;
		 g_objComponentId = objComponentId;
		 g_mtl = mtl;
		 g_isHit = true;
		 return vec4(t, normalize(vec3(p.x, 0, p.z)));
             }
	 }
	 return isect;
     }

     // default plane is aligned the z-axis
     vec4 intersectRect (int objId, int objIndex, int objComponentId, int mtl,
			 float distToOrigin, float size, mat3 rotation, mat3 invRotation,
			 vec3 rayOrigin, vec3 rayDir, vec4 isect) {
	 g_isHit = false;
	 vec3 c = vec3(0, 0, distToOrigin);
	 const vec3 defaultN = vec3(0, 0, 1);
	 vec3 n = rotation * defaultN;
	 float d = -dot(rotation * c, n);
	 float v = dot(n, rayDir);
	 float t = -(dot(n, rayOrigin) + d) / v;
	 if(EPSILON < t && t < isect.x){
	     float hSize = size * 0.5;
    	     vec3 p = rayOrigin + t * rayDir;
	     p = invRotation * p;
             if(-hSize < p.x && p.x < hSize &&
		-hSize < p.y && p.y < hSize ){
		 g_objId = objId;
		 g_objIndex = objIndex;
		 g_objComponentId = objComponentId;
		 g_mtl = mtl;
		 g_isHit = true;
        	 return vec4(t, n);
             }
	 }
	 return isect;
     }

     const float PI_4 = 12.566368;
     vec3 diffuseLighting(const vec3 p, const vec3 n, const vec3 diffuseColor,
							    const vec3 lightPos, const vec3 lightPower){
  	 vec3 v = lightPos - p;
  	 float d = dot(n, normalize(v));
  	 float r = length(v);
  	 return (d > 0. 
     // && lightVisibility(p, lightPos) == 1.
         ) ?
    		(lightPower * (abs(d) / (PI_4 * r * r))) * diffuseColor
    	      : vec3(0.0);
     }

     const vec3 lightPos = vec3(900, 450, 0);
     const vec3 lightPower = vec3(1000000.);
     const vec3 ambientFactor = vec3(0.1);
     const int MAX_TRACE_DEPTH = 7;
     const vec3 BLACK = vec3(0);
     const vec3 WHITE = vec3(1);
     const vec3 RED = vec3(1, 0, 0);
     const vec3 GREEN = vec3(0, 1, 0);
     const vec3 BLUE = vec3(0, 0, 1);
     const vec3 YELLOW = vec3(1, 1, 0);
     const vec3 PINK = vec3(1, 0, 1);
     const vec3 LIGHT_BLUE = vec3(0, 1, 1);
     float transparency = 0.8;
     vec3 calcColor(vec3 eye, vec3 ray){
	 vec3 l = BLACK;
	 float coeff = 1.0;
	 for (int depth = 0 ; depth < MAX_TRACE_DEPTH ; depth++){
	     vec4 result = vec4(99999.);
	     
	     {% for n  in range(0,  numSchottkySpheres ) %}
	     result = intersectSphere(ID_SCHOTTKY_SPHERE, {{ n }}, 0, MTL_DIFFUSE,
				      u_schottkySphere{{ n }}.xyz, u_schottkySphere{{ n }}.w, eye, ray, result);

	     if(u_selectedObjectId == ID_SCHOTTKY_SPHERE &&
		u_selectedObjectIndex == {{ n }}){
		 result = intersectYZCylinder(ID_AXIS_CYLINDER, {{ n }}, 0, MTL_DIFFUSE,
					      10., u_schottkySphere{{ n }}.xyz,
					      eye, ray, result);
		 
		 result = intersectXZCylinder(ID_AXIS_CYLINDER, {{ n }}, 1, MTL_DIFFUSE,
					      10., u_schottkySphere{{ n }}.xyz,
					      eye, ray, result);
		 result = intersectXYCylinder(ID_AXIS_CYLINDER, {{ n }}, 2, MTL_DIFFUSE,
					      10., u_schottkySphere{{ n }}.xyz,
					      eye, ray, result);
	     }
	     {% endfor %}

	     {% for n in range(0,  numBaseSpheres ) %}
	     result = intersectSphere(ID_BASE_SPHERE, {{ n }}, 0, MTL_DIFFUSE,
				      u_baseSphere{{ n }}.xyz, u_baseSphere{{ n }}.w, eye, ray, result);
	     
	     if(u_selectedObjectId == ID_BASE_SPHERE &&
		u_selectedObjectIndex == {{ n }}){
		 result = intersectYZCylinder(ID_AXIS_CYLINDER, {{ n }}, 0, MTL_DIFFUSE,
					      10., u_baseSphere{{ n }}.xyz,
					      eye, ray, result);
		 result = intersectXZCylinder(ID_AXIS_CYLINDER, {{ n }}, 1, MTL_DIFFUSE,
					      10., u_baseSphere{{ n }}.xyz,
					      eye, ray, result);
		 result = intersectXYCylinder(ID_AXIS_CYLINDER, {{ n }}, 2, MTL_DIFFUSE,
					      10., u_baseSphere{{ n }}.xyz,
					      eye, ray, result);
	     }
	     {% endfor %}

	     {% for n in range(0,  numTransformByPlanes ) %}
	     result = intersectRect(ID_TRANSFORM_BY_PLANES, {{ n }}, 0, MTL_DIFFUSE,
				    u_transformByPlanes{{ n }}[0],
				    u_transformByPlanes{{ n }}[2],
				    u_rotatePlaneMat3{{ n }},
				    u_invRotatePlaneMat3{{ n }},
				    eye, ray, result);
	     result = intersectRect(ID_TRANSFORM_BY_PLANES, {{ n }}, 1, MTL_DIFFUSE,
				    u_transformByPlanes{{ n }}[1],
				    u_transformByPlanes{{ n }}[2],
				    u_rotatePlaneMat3{{ n }} * u_twistPlaneMat3{{ n }},
				    u_invTwistPlaneMat3{{ n }} * u_invRotatePlaneMat3{{ n }},
				    eye, ray, result);
	     
	     {% endfor %}

	     {% for n in range(0, numCompoundParabolic) %}
	     result = intersectSphere(ID_COMPOUND_PARABOLIC, {{ n }}, 0, MTL_TRANSPARENT,
				      u_compoundParabolic{{ n }}[0].xyz,
				      u_compoundParabolic{{ n }}[0].w,
				      eye, ray, result);
             if(u_selectedObjectId == ID_COMPOUND_PARABOLIC &&
		u_selectedObjectIndex == {{ n }} &&
		u_selectedComponentId == 0){
		 result = intersectYZCylinder(ID_AXIS_CYLINDER, {{ n }}, 0, MTL_DIFFUSE,
					      10., u_compoundParabolic{{ n }}[0].xyz,
					      eye, ray, result);
		 result = intersectXZCylinder(ID_AXIS_CYLINDER, {{ n }}, 1, MTL_DIFFUSE,
					      10., u_compoundParabolic{{ n }}[0].xyz,
					      eye, ray, result);
		 result = intersectXYCylinder(ID_AXIS_CYLINDER, {{ n }}, 2, MTL_DIFFUSE,
					      10., u_compoundParabolic{{ n }}[0].xyz,
					      eye, ray, result);
	     }
	     result = intersectSphere(ID_COMPOUND_PARABOLIC, {{ n }}, 1, MTL_TRANSPARENT,
				      u_compoundParabolic{{ n }}[1].xyz,
				      u_compoundParabolic{{ n }}[1].w,
				      eye, ray, result);
	     if(u_selectedObjectId == ID_COMPOUND_PARABOLIC &&
		u_selectedObjectIndex == {{ n }} &&
		u_selectedComponentId == 1){
		 result = intersectYZCylinder(ID_AXIS_CYLINDER, {{ n }}, 0, MTL_DIFFUSE,
					      10., u_compoundParabolic{{ n }}[1].xyz,
					      eye, ray, result);
		 result = intersectXZCylinder(ID_AXIS_CYLINDER, {{ n }}, 1, MTL_DIFFUSE,
					      10., u_compoundParabolic{{ n }}[1].xyz,
					      eye, ray, result);
		 result = intersectXYCylinder(ID_AXIS_CYLINDER, {{ n }}, 2, MTL_DIFFUSE,
					      10., u_compoundParabolic{{ n }}[1].xyz,
					      eye, ray, result);
	     }
	     result = intersectSphere(ID_COMPOUND_PARABOLIC, {{ n }}, 2, MTL_TRANSPARENT,
				      u_compoundParabolic{{ n }}[2].xyz,
				      u_compoundParabolic{{ n }}[2].w,
				      eye, ray, result);
	     {% endfor %}

	     {% for n in range(0, numTransformBySpheres) %}
	     result = intersectSphere(ID_TRANSFORM_BY_SPHERES, {{ n }}, 0, MTL_TRANSPARENT,
				      u_transformBySpheres{{ n }}[0].xyz,
				      u_transformBySpheres{{ n }}[0].w,
				      eye, ray, result);
             if(u_selectedObjectId == ID_TRANSFORM_BY_SPHERES &&
		u_selectedObjectIndex == {{ n }} &&
		u_selectedComponentId == 0){
		 result = intersectYZCylinder(ID_AXIS_CYLINDER, {{ n }}, 0, MTL_DIFFUSE,
					      10., u_transformBySpheres{{ n }}[0].xyz,
					      eye, ray, result);
		 result = intersectXZCylinder(ID_AXIS_CYLINDER, {{ n }}, 1, MTL_DIFFUSE,
					      10., u_transformBySpheres{{ n }}[0].xyz,
					      eye, ray, result);
		 result = intersectXYCylinder(ID_AXIS_CYLINDER, {{ n }}, 2, MTL_DIFFUSE,
					      10., u_transformBySpheres{{ n }}[0].xyz,
					      eye, ray, result);
	     }
	     result = intersectSphere(ID_TRANSFORM_BY_SPHERES, {{ n }}, 1, MTL_TRANSPARENT,
				      u_transformBySpheres{{ n }}[1].xyz,
				      u_transformBySpheres{{ n }}[1].w,
				      eye, ray, result);
	     if(u_selectedObjectId == ID_TRANSFORM_BY_SPHERES &&
		u_selectedObjectIndex == {{ n }} &&
		u_selectedComponentId == 1){
		 result = intersectYZCylinder(ID_AXIS_CYLINDER, {{ n }}, 0, MTL_DIFFUSE,
					      10., u_transformBySpheres{{ n }}[1].xyz,
					      eye, ray, result);
		 result = intersectXZCylinder(ID_AXIS_CYLINDER, {{ n }}, 1, MTL_DIFFUSE,
					      10., u_transformBySpheres{{ n }}[1].xyz,
					      eye, ray, result);
		 result = intersectXYCylinder(ID_AXIS_CYLINDER, {{ n }}, 2, MTL_DIFFUSE,
					      10., u_transformBySpheres{{ n }}[1].xyz,
					      eye, ray, result);
	     }
	     result = intersectSphere(ID_TRANSFORM_BY_SPHERES, {{ n }}, 2, MTL_TRANSPARENT,
				      u_transformBySpheres{{ n }}[2].xyz,
				      u_transformBySpheres{{ n }}[2].w,
				      eye, ray, result);
	     {% endfor %}

	     {% for n in range(0, numCompoundLoxodromic) %}
	     result = intersectSphere(ID_COMPOUND_LOXODROMIC, {{ n }}, 0, MTL_TRANSPARENT,
				      u_compoundLoxodromic{{ n }}[0].xyz,
				      u_compoundLoxodromic{{ n }}[0].w,
				      eye, ray, result);
             if(u_selectedObjectId == ID_COMPOUND_LOXODROMIC &&
		u_selectedObjectIndex == {{ n }} &&
		u_selectedComponentId == 0){
		 result = intersectYZCylinder(ID_AXIS_CYLINDER, {{ n }}, 0, MTL_DIFFUSE,
					      10., u_compoundLoxodromic{{ n }}[0].xyz,
					      eye, ray, result);
		 result = intersectXZCylinder(ID_AXIS_CYLINDER, {{ n }}, 1, MTL_DIFFUSE,
					      10., u_compoundLoxodromic{{ n }}[0].xyz,
					      eye, ray, result);
		 result = intersectXYCylinder(ID_AXIS_CYLINDER, {{ n }}, 2, MTL_DIFFUSE,
					      10., u_compoundLoxodromic{{ n }}[0].xyz,
					      eye, ray, result);
	     }
	     result = intersectSphere(ID_COMPOUND_LOXODROMIC, {{ n }}, 1, MTL_TRANSPARENT,
				      u_compoundLoxodromic{{ n }}[1].xyz,
				      u_compoundLoxodromic{{ n }}[1].w,
				      eye, ray, result);
             if(u_selectedObjectId == ID_COMPOUND_LOXODROMIC &&
		u_selectedObjectIndex == {{ n }} &&
		u_selectedComponentId == 1){
		 result = intersectYZCylinder(ID_AXIS_CYLINDER, {{ n }}, 0, MTL_DIFFUSE,
					      10., u_compoundLoxodromic{{ n }}[1].xyz,
					      eye, ray, result);
		 result = intersectXZCylinder(ID_AXIS_CYLINDER, {{ n }}, 1, MTL_DIFFUSE,
					      10., u_compoundLoxodromic{{ n }}[1].xyz,
					      eye, ray, result);
		 result = intersectXYCylinder(ID_AXIS_CYLINDER, {{ n }}, 2, MTL_DIFFUSE,
					      10., u_compoundLoxodromic{{ n }}[1].xyz,
					      eye, ray, result);
	     }
	     result = intersectSphere(ID_COMPOUND_LOXODROMIC, {{ n }}, 2, MTL_TRANSPARENT,
				      u_compoundLoxodromic{{ n }}[2].xyz,
				      u_compoundLoxodromic{{ n }}[2].w,
				      eye, ray, result);
	     result = intersectSphere(ID_COMPOUND_LOXODROMIC, {{ n }}, 3, MTL_TRANSPARENT,
				      u_compoundLoxodromic{{ n }}[3].xyz,
				      u_compoundLoxodromic{{ n }}[3].w,
				      eye, ray, result);
	     result = intersectSphere(ID_COMPOUND_LOXODROMIC, {{ n }}, 4, MTL_TRANSPARENT,
				      u_compoundLoxodromic{{ n }}[4].xyz,
				      u_compoundLoxodromic{{ n }}[4].w,
				      eye, ray, result);
	     result = intersectSphere(ID_COMPOUND_LOXODROMIC, {{ n }}, 5, MTL_TRANSPARENT,
				      u_compoundLoxodromic{{ n }}[5].xyz,
				      50.,
				      eye, ray, result);
             if(u_selectedObjectId == ID_COMPOUND_LOXODROMIC &&
		u_selectedObjectIndex == {{ n }} &&
		u_selectedComponentId == 5){
		 result = intersectYZCylinder(ID_AXIS_CYLINDER, {{ n }}, 0, MTL_DIFFUSE,
					      10., u_compoundLoxodromic{{ n }}[5].xyz,
					      eye, ray, result);
		 result = intersectXZCylinder(ID_AXIS_CYLINDER, {{ n }}, 1, MTL_DIFFUSE,
					      10., u_compoundLoxodromic{{ n }}[5].xyz,
					      eye, ray, result);
		 result = intersectXYCylinder(ID_AXIS_CYLINDER, {{ n }}, 2, MTL_DIFFUSE,
					      10., u_compoundLoxodromic{{ n }}[5].xyz,
					      eye, ray, result);
	     }
	     result = intersectSphere(ID_COMPOUND_LOXODROMIC, {{ n }}, 6, MTL_TRANSPARENT,
				      u_compoundLoxodromic{{ n }}[6].xyz,
				      50.,
				      eye, ray, result);
             if(u_selectedObjectId == ID_COMPOUND_LOXODROMIC &&
		u_selectedObjectIndex == {{ n }} &&
		u_selectedComponentId == 6){
		 result = intersectYZCylinder(ID_AXIS_CYLINDER, {{ n }}, 0, MTL_DIFFUSE,
					      10., u_compoundLoxodromic{{ n }}[6].xyz,
					      eye, ray, result);
		 result = intersectXZCylinder(ID_AXIS_CYLINDER, {{ n }}, 1, MTL_DIFFUSE,
					      10., u_compoundLoxodromic{{ n }}[6].xyz,
					      eye, ray, result);
		 result = intersectXYCylinder(ID_AXIS_CYLINDER, {{ n }}, 2, MTL_DIFFUSE,
					      10., u_compoundLoxodromic{{ n }}[6].xyz,
					      eye, ray, result);
	     }
	     result = intersectSphere(ID_COMPOUND_LOXODROMIC, {{ n }}, 7, MTL_TRANSPARENT,
				      u_compoundLoxodromic{{ n }}[7].xyz,
				      50.,
				      eye, ray, result);
             if(u_selectedObjectId == ID_COMPOUND_LOXODROMIC &&
		u_selectedObjectIndex == {{ n }} &&
		u_selectedComponentId == 7){
		 result = intersectYZCylinder(ID_AXIS_CYLINDER, {{ n }}, 0, MTL_DIFFUSE,
					      10., u_compoundLoxodromic{{ n }}[7].xyz,
					      eye, ray, result);
		 result = intersectXZCylinder(ID_AXIS_CYLINDER, {{ n }}, 1, MTL_DIFFUSE,
					      10., u_compoundLoxodromic{{ n }}[7].xyz,
					      eye, ray, result);
		 result = intersectXYCylinder(ID_AXIS_CYLINDER, {{ n }}, 2, MTL_DIFFUSE,
					      10., u_compoundLoxodromic{{ n }}[7].xyz,
					      eye, ray, result);
	     }
	     {% endfor %}
	     
  	     if(result.x != 99999.){
		 vec3 matColor = WHITE;
		 if( g_objId == ID_SCHOTTKY_SPHERE){
		     g_mtl = MTL_TRANSPARENT;
		     matColor = (g_objIndex == u_selectedObjectIndex &&
				 g_objId == u_selectedObjectId) ? RED : WHITE;
		 }else if(g_objId == ID_BASE_SPHERE){
		     matColor = (g_objId == u_selectedObjectId &&
				 g_objIndex == u_selectedObjectIndex) ? RED : GREEN;
		 }else if(g_objId == ID_AXIS_CYLINDER){
		     matColor = (g_objComponentId == u_selectedAxis) ? RED : WHITE;
		 }else if(g_objId == ID_TRANSFORM_BY_PLANES){
		     matColor = (g_objId == u_selectedObjectId &&
				 g_objIndex == u_selectedObjectIndex)?
				RED : BLUE;
		 }else if(g_objId == ID_TRANSFORM_BY_SPHERES){
		     matColor = (g_objComponentId == 0) ? LIGHT_BLUE : vec3(0.2, 0.2, 0.9);
		     matColor = (g_objComponentId == 1) ? YELLOW : matColor;
		     matColor = (g_objId == u_selectedObjectId &&
				 g_objIndex == u_selectedObjectIndex &&
				 g_objComponentId == u_selectedComponentId) ? RED : matColor;
		 }else if(g_objId == ID_COMPOUND_PARABOLIC){
		     matColor = (g_objComponentId == 0) ? LIGHT_BLUE : vec3(0.2, 0.2, 0.9);
		     matColor = (g_objComponentId == 1) ? YELLOW : matColor;
		     matColor = (g_objId == u_selectedObjectId &&
				 g_objIndex == u_selectedObjectIndex &&
				 g_objComponentId == u_selectedComponentId) ? RED : matColor;
		 }else if(g_objId == ID_COMPOUND_LOXODROMIC){
		     matColor = (g_objComponentId == 0) ? LIGHT_BLUE : vec3(0.2, 0.2, 0.9);
		     matColor = (g_objComponentId == 1) ? YELLOW : matColor;
		     matColor = (g_objComponentId == 3) ? PINK : matColor;
		     matColor = (g_objComponentId == 4) ? GREEN : matColor;
		     matColor = (g_objComponentId == 5) ? BLUE : matColor;
		     matColor = (g_objComponentId == 6) ? WHITE : matColor;
		     matColor = (g_objComponentId == 7) ? WHITE : matColor;
                     matColor = (g_objId == u_selectedObjectId &&
				 g_objIndex == u_selectedObjectIndex &&
				 g_objComponentId == u_selectedComponentId) ? RED : matColor;
		 }
		 
    		 vec3 intersection = eye + ray * result.x;
		 vec3 normal = result.yzw;
		 vec3 diffuse = diffuseLighting(intersection, normal, matColor, lightPos, lightPower);
		 vec3 ambient = matColor * ambientFactor;
		 if(g_mtl == MTL_TRANSPARENT){
		     coeff *= transparency;
		     l += (diffuse + ambient) * coeff;
		     eye = intersection + ray * 0.01;
		     continue;
		 }else{
		     l += (diffuse + ambient) * coeff;
		 }
	     }
	     break;
	 }
  	 return l;
     }

     vec3 hsv2rgb(vec3 c){
	 const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	 vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
	 return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
     }


     const float DISPLAY_GAMMA_COEFF = 1. / 2.2;
     vec3 gammaCorrect(vec3 rgb) {
	 return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),
                     (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),
                     (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));
     }

     vec3 calcRay (const vec3 eye, const vec3 target,
		   const vec3 up, const float fov,
		   const float width, const float height, const vec2 coord){
	 float imagePlane = (height * .5) / tan(radians(fov) * .5);
  	 vec3 v = normalize(target - eye);
 	 vec3 focalXAxis = normalize(cross(v, up));
  	 vec3 focalYAxis =  normalize(cross(v, focalXAxis ));
  	 vec3 center = v * imagePlane;
  	 vec3 origin = center - (focalXAxis * (width  * .5)) - (focalYAxis * (height * .5));
  	 return normalize(origin + (focalXAxis * coord.x) + (focalYAxis * (height - coord.y)));
     }

     const float SAMPLE_NUM = 10.;
     void main(){	 
	 vec4 sum = vec4(0);
	 for(float i = 0. ; i < SAMPLE_NUM ; i++){
             vec2 coordOffset = rand2n(gl_FragCoord.xy, i);
             
             vec3 ray = calcRay(u_eye, u_target, u_up, u_fov,
    		               	u_iResolution.x, u_iResolution.y,
        		        gl_FragCoord.xy + coordOffset);
             
             sum += vec4(gammaCorrect(calcColor(u_eye, ray)), 1.);
	 }
	 gl_FragColor = vec4(sum/SAMPLE_NUM);
     }
    </script>
    <script id="3dOrbitTemplate" type="x-shader/x-fragment">
     precision mediump float;
     uniform vec2 u_iResolution;
     uniform float u_iGlobalTime;
     uniform int u_selectedObjectId;
     uniform int u_selectedObjectIndex;
     uniform int u_selectedComponentId;
     uniform int u_selectedAxis;
     uniform vec3 u_eye;
     uniform vec3 u_up;
     uniform vec3 u_target;
     uniform float u_fov;
     uniform int u_numIterations;
     
     {% for n  in range(0,  numSchottkySpheres ) %}
     uniform vec4 u_schottkySphere{{ n }};
     {% endfor %}

     {% for n  in range(0,  numSchottkySpheres ) %}
     float u_schottkySphere{{ n }}r2 = u_schottkySphere{{ n }}.w * u_schottkySphere{{ n }}.w;
     {% endfor %}

     {% for n  in range(0,  numBaseSpheres ) %}
     uniform vec4 u_baseSphere{{ n }};
     {% endfor %}

     {% for n in range(0,  numTransformByPlanes ) %}
     uniform float u_transformByPlanes{{ n }}[6];
     uniform mat3 u_rotatePlaneMat3{{ n }};
     uniform mat3 u_invRotatePlaneMat3{{ n }};
     uniform mat3 u_twistPlaneMat3{{ n }};
     uniform mat3 u_invTwistPlaneMat3{{ n }};
     {% endfor %}

     {% for n in range(0, numTransformBySpheres) %}
     //[innerSphere, outerSphere, invertedSphere]
     uniform vec4 u_transformBySpheres{{ n }}[3];
     {% endfor %}

     {% for n in range(0, numCompoundParabolic) %}
     //[innerSphere, outerSphere, invertedSphere]
     uniform vec4 u_compoundParabolic{{ n }}[3];
     uniform mat3 u_compoundRotateMat3{{ n }};
     uniform mat3 u_invCompoundRotateMat3{{ n }};
     {% endfor %}

     {% for n in range(0, numCompoundLoxodromic) %}
     //[innerSphere, outerSphere, invertedSphere, s3, s4, p, q1, q2]
     uniform vec4 u_compoundLoxodromic{{ n }}[8];
     {% endfor %}
     
     uniform bool u_displayGenerators;
     
     int g_mtl = -1;
     int g_objId = -1;
     int g_objIndex = -1;
     int g_objComponentId = -1;
     bool g_isHit = false;

     const int ID_SCHOTTKY_SPHERE = 0;
     const int ID_BASE_SPHERE = 1;
     const int ID_TRANSFORM_BY_PLANES = 2;
     const int ID_TRANSFORM_BY_SPHERES = 3;
     const int ID_COMPOUND_PARABOLIC = 4;
     const int ID_COMPOUND_LOXODROMIC = 5;

     const int ID_AXIS_CYLINDER = 100;
     const int ID_KLEIN_ORBIT = 101;

     const float EPSILON = 0.01;

     const int MTL_DIFFUSE = 0;
     const int MTL_TRANSPARENT = 1;
     
     // from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/
     vec2 rand2n(vec2 co, float sampleIndex) {
	 vec2 seed = co * (sampleIndex + 1.0);
	 seed+=vec2(-1,1);
	 // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html
	 return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),
                     fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));
     }

     vec4 intersectSphere(int objId, int objIndex, int objComponentId, int mtl,
			  vec3 sphereCenter, float radius, 
			  vec3 rayOrigin, vec3 rayDir, vec4 isect){
	 g_isHit = false;
	 vec3 v = rayOrigin - sphereCenter;
	 float b = dot(rayDir, v);
	 float c = dot(v, v) - radius * radius;
	 float d = b * b - c;
	 if(d >= 0.){
             float s = sqrt(d);
             float t = -b - s;
             if(t <= EPSILON) t = -b + s;
             if(EPSILON < t && t < isect.x){
		 vec3 p = (rayOrigin + t * rayDir);
		 g_objId = objId;
		 g_objIndex = objIndex;
		 g_objComponentId = objComponentId;
		 g_mtl = mtl;
		 g_isHit = true;
		 return vec4(t, normalize(p - sphereCenter));
             }
	 }
	 return isect;
     }

     // default plane is aligned the z-axis
     vec4 intersectRect (int objId, int objIndex, int objComponentId, int mtl,
			 float distToOrigin, float size, mat3 rotation, mat3 invRotation,
			 vec3 rayOrigin, vec3 rayDir, vec4 isect) {
	 g_isHit = false;
	 vec3 c = vec3(0, 0, distToOrigin);
	 const vec3 defaultN = vec3(0, 0, 1);
	 vec3 n = rotation * defaultN;
	 float d = -dot(rotation * c, n);
	 float v = dot(n, rayDir);
	 float t = -(dot(n, rayOrigin) + d) / v;
	 if(EPSILON < t && t < isect.x){
	     float hSize = size * 0.5;
    	     vec3 p = rayOrigin + t * rayDir;
	     p = invRotation * p;
             if(-hSize < p.x && p.x < hSize &&
		-hSize < p.y && p.y < hSize ){
		 g_objId = objId;
		 g_objIndex = objIndex;
		 g_objComponentId = objComponentId;
		 g_mtl = mtl;
		 g_isHit = true;
        	 return vec4(t, n);
             }
	 }
	 return isect;
     }
     
     vec3 sphereInvert(const vec3 pos, const vec3 spherePos, const float sphereR2){
	 return ((pos - spherePos) * sphereR2)/(distance(pos, spherePos) * distance(pos, spherePos) ) + spherePos;
     }

     float loopNum = 0.;

     {% for n in range(0,  numTransformBySpheres ) %}
     float s0r2{{ n }} = u_transformBySpheres{{ n }}[0].w * u_transformBySpheres{{ n }}[0].w;
     float s1r2{{ n }} = u_transformBySpheres{{ n }}[1].w * u_transformBySpheres{{ n }}[1].w;
     {% endfor %}

     {% for n in range(0, numCompoundParabolic) %}
     float comp0r2{{ n }} = u_compoundParabolic{{ n }}[0].w * u_compoundParabolic{{ n }}[0].w;
     float comp1r2{{ n }} = u_compoundParabolic{{ n }}[1].w * u_compoundParabolic{{ n }}[1].w;
     {% endfor %}

     {% for n in range(0, numCompoundLoxodromic) %}
     float loxoInnerR2{{ n }} = u_compoundLoxodromic{{ n }}[0].w * u_compoundLoxodromic{{ n }}[0].w;
     float loxoOuterR2{{ n }} = u_compoundLoxodromic{{ n }}[1].w * u_compoundLoxodromic{{ n }}[1].w;
     float loxoS3R2{{ n }} = u_compoundLoxodromic{{ n }}[3].w * u_compoundLoxodromic{{ n }}[3].w;
     float loxoS4R2{{ n }} = u_compoundLoxodromic{{ n }}[4].w * u_compoundLoxodromic{{ n }}[4].w;
     {% endfor %}
     
     const int MAX_KLEIN_ITARATION = 30;
     const float NO_HIT = 99999.;
     float distKlein(vec3 pos){
	 loopNum = 0.;
	 float dr = 1.;
	 bool loopEnd = true;

	 for(int i = 0 ; i < MAX_KLEIN_ITARATION ; i++){
	     if(i >= u_numIterations) break;
	     loopEnd = true;
	     {% for n in range(0, numCompoundParabolic) %}
	     if(distance(pos, u_compoundParabolic{{ n }}[0].xyz) < u_compoundParabolic{{ n }}[0].w){
		 vec3 diff0 = (pos - u_compoundParabolic{{ n }}[0].xyz);
		 dr *= comp0r2{{ n }} / dot(diff0, diff0);
		 pos = sphereInvert(pos, u_compoundParabolic{{ n }}[0].xyz, comp0r2{{ n }});

		 vec3 diff1 = (pos - u_compoundParabolic{{ n }}[1].xyz);
		 dr *= comp1r2{{ n }} / dot(diff1, diff1);
		 pos = sphereInvert(pos, u_compoundParabolic{{ n }}[1].xyz, comp1r2{{ n }});

		 pos = u_compoundRotateMat3{{ n }} *  pos;
		 
		 loopEnd = false;
		 loopNum++;
	     }else if(distance(pos, u_compoundParabolic{{ n }}[2].xyz) >= u_compoundParabolic{{ n }}[2].w){
		 vec3 diff1 = (pos - u_compoundParabolic{{ n }}[1].xyz);
		 dr *= comp1r2{{ n }} / dot(diff1, diff1);
		 pos = sphereInvert(pos, u_compoundParabolic{{ n }}[1].xyz,
				    comp1r2{{ n }});

		 vec3 diff0 = (pos - u_compoundParabolic{{ n }}[0].xyz);
		 dr *= comp0r2{{ n }} / dot(diff0, diff0);
		 pos = sphereInvert(pos, u_compoundParabolic{{ n }}[0].xyz, comp0r2{{ n }});

		 pos = u_invCompoundRotateMat3{{ n }} * pos;
		 
		 loopEnd = false;
		 loopNum++;
	     }
	     
	     {% endfor %}

	     {% for n in range(0,  numTransformBySpheres ) %}
	     if(distance(pos, u_transformBySpheres{{ n }}[0].xyz) < u_transformBySpheres{{ n }}[0].w){
		 vec3 diff0 = (pos - u_transformBySpheres{{ n }}[0].xyz);
		 dr *= s0r2{{ n }} / dot(diff0, diff0);
		 pos = sphereInvert(pos, u_transformBySpheres{{ n }}[0].xyz, s0r2{{ n }});

		 vec3 diff1 = (pos - u_transformBySpheres{{ n }}[1].xyz);
		 dr *= s1r2{{ n }} / dot(diff1, diff1);
		 pos = sphereInvert(pos, u_transformBySpheres{{ n }}[1].xyz, s1r2{{ n }});
		 
		 loopEnd = false;
		 loopNum++;
	     }else if(distance(pos, u_transformBySpheres{{ n }}[2].xyz) >= u_transformBySpheres{{ n }}[2].w){
		 vec3 diff1 = (pos - u_transformBySpheres{{ n }}[1].xyz);
		 dr *= s1r2{{ n }} / dot(diff1, diff1);
		 pos = sphereInvert(pos, u_transformBySpheres{{ n }}[1].xyz,
				    s1r2{{ n }});

		 vec3 diff0 = (pos - u_transformBySpheres{{ n }}[0].xyz);
		 dr *= s0r2{{ n }} / dot(diff0, diff0);
		 pos = sphereInvert(pos, u_transformBySpheres{{ n }}[0].xyz, s0r2{{ n }});

		 loopEnd = false;
		 loopNum++;
	     }
	     {% endfor %}
	     
	     {% if numSchottkySpheres > 2 %}
	     {% for n  in range(0,  numSchottkySpheres ) %}
	     {% if n == 0 %}
	     if(distance(pos, u_schottkySphere0.xyz) < u_schottkySphere0.w){
		 vec3 diff = (pos - u_schottkySphere0.xyz);
		 dr *= u_schottkySphere0r2 / dot(diff, diff);
		 pos = sphereInvert(pos, u_schottkySphere0.xyz, u_schottkySphere0r2);
		 loopEnd = false;
		 loopNum++;
	     }
	     {% else %}
	     else if(distance(pos, u_schottkySphere{{ n }}.xyz) < u_schottkySphere{{ n }}.w){
		 vec3 diff = (pos - u_schottkySphere{{ n }}.xyz);
		 dr *= u_schottkySphere{{ n }}r2 / dot(diff, diff);
		 pos = sphereInvert(pos, u_schottkySphere{{ n }}.xyz,
				    u_schottkySphere{{ n }}r2);
		 loopEnd = false;
		 loopNum++;
	     }
	     {% endif %}
	     {% endfor %}
	     {% elif numSchottkySpheres == 2 %}
	     if(distance(pos, u_schottkySphere0.xyz) < u_schottkySphere0.w){
		 vec3 diff = (pos - u_schottkySphere0.xyz);
		 dr *= u_schottkySphere0r2 / dot(diff, diff);
		 pos = sphereInvert(pos, u_schottkySphere0.xyz,
				    u_schottkySphere0r2);
		 loopEnd = false;
		 loopNum++;
	     }else if(distance(pos, u_schottkySphere1.xyz) < u_schottkySphere1.w){
		 vec3 diff = (pos - u_schottkySphere1.xyz);
		 dr *= u_schottkySphere1r2 / dot(diff, diff);
		 pos = sphereInvert(pos, u_schottkySphere1.xyz, u_schottkySphere1r2);
		 loopEnd = false;
		 loopNum++;
	     }
	     {% elif numSchottkySpheres == 1 %}
	     if(distance(pos, u_schottkySphere0.xyz) < u_schottkySphere0.w){
		 vec3 diff = (pos - u_schottkySphere0.xyz);
		 dr *= u_schottkySphere0r2 / dot(diff, diff);
		 pos = sphereInvert(pos, u_schottkySphere0.xyz, u_schottkySphere0r2);
		 loopEnd = false;
		 loopNum++;
	     }
	     {% endif %}
	     {% for n in range(0,  numTransformByPlanes ) %}
	     pos = u_invRotatePlaneMat3{{ n }} * pos;
	     if(pos.z < u_transformByPlanes{{ n }}[0] || u_transformByPlanes{{ n }}[1] < pos.z){
		 pos.z -= u_transformByPlanes{{ n }}[0];
		 float nn = floor(pos.z / (u_transformByPlanes{{n}}[1] - u_transformByPlanes{{ n }}[0]));
		 pos.z = mod(pos.z,
			     u_transformByPlanes{{ n }}[1] - u_transformByPlanes{{ n }}[0]);
		 pos.z += u_transformByPlanes{{ n }}[0];
		 float theta = -radians(u_transformByPlanes{{ n }}[5]) * nn;
		 float cosTheta = cos(theta);
		 float sinTheta = sin(theta);
		 mat3 m = mat3(cosTheta, -sinTheta, 0,
			       sinTheta, cosTheta, 0,
			       0, 0, 1);
		 pos = m * pos;

		 loopEnd = false;
		 loopNum ++;
	     }
	     pos = u_rotatePlaneMat3{{ n }} * pos;
	     {% endfor %}
             {% for n in range(0, numCompoundLoxodromic) %}
             if(distance(pos, u_compoundLoxodromic{{ n }}[0].xyz) < u_compoundLoxodromic{{ n }}[0].w){
		 vec3 diff4 = (pos - u_compoundLoxodromic{{ n }}[4].xyz);
		 dr *= loxoS4R2{{ n }} / dot(diff4, diff4);
		 pos = sphereInvert(pos, u_compoundLoxodromic{{ n }}[4].xyz, loxoS4R2{{ n }});
                 
                 vec3 diff3 = (pos - u_compoundLoxodromic{{ n }}[3].xyz);
		 dr *= loxoS3R2{{ n }} / dot(diff3, diff3);
		 pos = sphereInvert(pos, u_compoundLoxodromic{{ n }}[3].xyz, loxoS3R2{{ n }});
                 
		 vec3 diff0 = (pos - u_compoundLoxodromic{{ n }}[0].xyz);
		 dr *= loxoInnerR2{{ n }} / dot(diff0, diff0);
		 pos = sphereInvert(pos, u_compoundLoxodromic{{ n }}[0].xyz, loxoInnerR2{{ n }});

		 vec3 diff1 = (pos - u_compoundLoxodromic{{ n }}[1].xyz);
		 dr *= loxoOuterR2{{ n }} / dot(diff1, diff1);
		 pos = sphereInvert(pos, u_compoundLoxodromic{{ n }}[1].xyz, loxoOuterR2{{ n }});
		 
		 loopEnd = false;
		 loopNum++;
	     }else if(distance(pos, u_compoundLoxodromic{{ n }}[2].xyz) >= u_compoundLoxodromic{{ n }}[2].w){
		 vec3 diff1 = (pos - u_compoundLoxodromic{{ n }}[1].xyz);
		 dr *= loxoOuterR2{{ n }} / dot(diff1, diff1);
		 pos = sphereInvert(pos, u_compoundLoxodromic{{ n }}[1].xyz,
				    loxoOuterR2{{ n }});

		 vec3 diff0 = (pos - u_compoundLoxodromic{{ n }}[0].xyz);
		 dr *= loxoInnerR2{{ n }} / dot(diff0, diff0);
		 pos = sphereInvert(pos, u_compoundLoxodromic{{ n }}[0].xyz, loxoInnerR2{{ n }});

                 vec3 diff3 = (pos - u_compoundLoxodromic{{ n }}[3].xyz);
		 dr *= loxoS3R2{{ n }} / dot(diff3, diff3);
		 pos = sphereInvert(pos, u_compoundLoxodromic{{ n }}[3].xyz, loxoS3R2{{ n }});

		 vec3 diff4 = (pos - u_compoundLoxodromic{{ n }}[4].xyz);
		 dr *= loxoS4R2{{ n }} / dot(diff4, diff4);
		 pos = sphereInvert(pos, u_compoundLoxodromic{{ n }}[4].xyz, loxoS4R2{{ n }});

		 loopEnd = false;
		 loopNum++;
	     }
             {% endfor %}
	     
	     if(loopEnd == true) break;
	 }
	 {% if numBaseSpheres == 1 %}
	 return (distance(pos, u_baseSphere0.xyz) - u_baseSphere0.w) / abs(dr) * 0.08;
	 {% elif numBaseSpheres > 1 %}
	 float minDist = (distance(pos, u_baseSphere0.xyz) - u_baseSphere0.w) / abs(dr) * 0.08;
	 {% for n  in range(1,  numBaseSpheres ) %}
	 minDist = min(minDist,
		       (distance(pos, u_baseSphere{{ n }}.xyz) - u_baseSphere{{ n }}.w) / abs(dr) * 0.08);
	 {% endfor %}
	 return minDist;
         {% else %}
         return NO_HIT;
	 {% endif %}
     }

     vec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,
									   const float width, const float height, const vec2 coord){
	 float imagePlane = (height * .5) / tan(radians(fov) * .5);
	 vec3 v = normalize(target - eye);
	 vec3 xaxis = normalize(cross(v, up));
	 vec3 yaxis =  normalize(cross(v, xaxis));
	 vec3 center = v * imagePlane;
	 vec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));
	 return normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));
     }

     const vec4 K = vec4(1.0, .666666, .333333, 3.0);
     vec3 hsv2rgb(const vec3 c){
	 vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
	 return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
     }

     float distFunc(vec3 p){
	 return distKlein(p);
     }

     const vec2 d = vec2(0.01, 0.);
     vec3 getNormal(const vec3 p){
	 return normalize(vec3(distFunc(p + d.xyy) - distFunc(p - d.xyy),
                               distFunc(p + d.yxy) - distFunc(p - d.yxy),
                               distFunc(p + d.yyx) - distFunc(p - d.yyx)));
     }

     const float PI_4 = 12.566368;
     const vec3 LIGHTING_FACT = vec3(0.);
     const vec3 BLACK = vec3(0);
     vec3 diffuseLighting(const vec3 p, const vec3 n, const vec3 diffuseColor,
			  const vec3 lightPos, const vec3 lightPower){
	 vec3 v = lightPos - p;
	 float dot = dot(n, normalize(v));
	 float r = length(v);
	 return (dot > 0.) ?
		(lightPower * (dot / (PI_4 * r * r))) * diffuseColor
	      : BLACK;
     }

     const vec3 lightPos = vec3(400, 400, 400);
     const vec3 lightPos2 = vec3(400., -400., -400);
     const vec3 lightPower = vec3(2000000.);

     const int MAX_MARCHING_LOOP = 800;
     vec4 march(int objId, int objIndex, int objComponentId, int mtl,
		const vec3 origin, const  vec3 ray,
		const float threshold, vec4 isect){
	 vec3 rayPos = origin;
	 float dist;
	 float rayLength = 0.;
	 for(int i = 0 ; i < MAX_MARCHING_LOOP ; i++){
	     dist = distFunc(rayPos);
	     rayLength += dist;
	     rayPos = origin + ray * rayLength ;
	     if(dist < threshold) break;
	 }
	 if(dist < EPSILON && rayLength < isect.x){
	     g_objId = objId;
	     g_objIndex = objIndex;
	     g_objComponentId = objComponentId;
	     g_mtl = mtl;
	     g_isHit = true;
	     return vec4(rayLength);
	 }else{
	     return isect;
	 }
     }

     const int MAX_TRACE_DEPTH = 5;
     vec3 ambientFactor = vec3(0.1);
     const vec3 WHITE = vec3(1);
     const vec3 RED = vec3(1, 0, 0);
     const vec3 GREEN = vec3(0, 1, 0);
     const vec3 BLUE = vec3(0, 0, 1);
     const vec3 YELLOW = vec3(1, 1, 0);
     const vec3 PINK = vec3(1, 0, 1);
     const vec3 LIGHT_BLUE = vec3(0, 1, 1);
     float transparency = 0.8;
     vec3 calcColor(vec3 eye, vec3 ray){
	 vec3 l = BLACK;
	 float coeff = 1.;
	 for (int depth = 0 ; depth < MAX_TRACE_DEPTH ; depth++){
	     vec4 result = vec4(NO_HIT);

             {% if numBaseSpheres >= 1 %}
	     result = march(ID_KLEIN_ORBIT, 0, 0, MTL_DIFFUSE,
			    eye, ray, 0.01, result);
             {% endif %}

	     if(u_displayGenerators){
		 
		 {% for n  in range(0,  numSchottkySpheres ) %}
		 result = intersectSphere(ID_SCHOTTKY_SPHERE, {{ n }}, 0, MTL_TRANSPARENT,
					  u_schottkySphere{{ n }}.xyz, u_schottkySphere{{ n }}.w,
					  eye, ray, result);
		 {% endfor %}

		 {% for n in range(0,  numBaseSpheres ) %}
		 result = intersectSphere(ID_BASE_SPHERE, {{ n }}, 0, MTL_TRANSPARENT,
					  u_baseSphere{{ n }}.xyz, u_baseSphere{{ n }}.w,
					  eye, ray, result);
		 
		 {% endfor %}

		 {% for n in range(0,  numTransformByPlanes ) %}
		 result = intersectRect(ID_TRANSFORM_BY_PLANES, {{ n }}, 0, MTL_DIFFUSE,
					u_transformByPlanes{{ n }}[0],
					u_transformByPlanes{{ n }}[2],
					u_rotatePlaneMat3{{ n }},
					u_invRotatePlaneMat3{{ n }},
					eye, ray, result);
		 result = intersectRect(ID_TRANSFORM_BY_PLANES, {{ n }}, 1, MTL_DIFFUSE,
					u_transformByPlanes{{ n }}[1],
					u_transformByPlanes{{ n }}[2],
					u_rotatePlaneMat3{{ n }} * u_twistPlaneMat3{{ n }},
					u_invTwistPlaneMat3{{ n }} * u_invRotatePlaneMat3{{ n }},
					eye, ray, result);
		 
		 {% endfor %}

		 {% for n in range(0, numTransformBySpheres) %}
		 result = intersectSphere(ID_TRANSFORM_BY_SPHERES, {{ n }}, 0, MTL_TRANSPARENT,
					  u_transformBySpheres{{ n }}[0].xyz,
					  u_transformBySpheres{{ n }}[0].w,
					  eye, ray, result);
		 result = intersectSphere(ID_TRANSFORM_BY_SPHERES, {{ n }}, 1, MTL_TRANSPARENT,
					  u_transformBySpheres{{ n }}[1].xyz,
					  u_transformBySpheres{{ n }}[1].w,
					  eye, ray, result);
		 result = intersectSphere(ID_TRANSFORM_BY_SPHERES, {{ n }}, 2, MTL_TRANSPARENT,
					  u_transformBySpheres{{ n }}[2].xyz,
					  u_transformBySpheres{{ n }}[2].w,
					  eye, ray, result);
		 {% endfor %}

		 {% for n in range(0, numCompoundParabolic) %}
		 result = intersectSphere(ID_COMPOUND_PARABOLIC, {{ n }}, 0, MTL_TRANSPARENT,
					  u_compoundParabolic{{ n }}[0].xyz,
					  u_compoundParabolic{{ n }}[0].w,
					  eye, ray, result);
		 result = intersectSphere(ID_COMPOUND_PARABOLIC, {{ n }}, 1, MTL_TRANSPARENT,
					  u_compoundParabolic{{ n }}[1].xyz,
					  u_compoundParabolic{{ n }}[1].w,
					  eye, ray, result);
		 result = intersectSphere(ID_COMPOUND_PARABOLIC, {{ n }}, 2, MTL_TRANSPARENT,
					  u_compoundParabolic{{ n }}[2].xyz,
					  u_compoundParabolic{{ n }}[2].w,
					  eye, ray, result);
		 {% endfor %}

		 {% for n in range(0, numCompoundLoxodromic) %}
		 result = intersectSphere(ID_COMPOUND_LOXODROMIC, {{ n }}, 0, MTL_TRANSPARENT,
					  u_compoundLoxodromic{{ n }}[0].xyz,
					  u_compoundLoxodromic{{ n }}[0].w,
					  eye, ray, result);
		 result = intersectSphere(ID_COMPOUND_LOXODROMIC, {{ n }}, 1, MTL_TRANSPARENT,
					  u_compoundLoxodromic{{ n }}[1].xyz,
					  u_compoundLoxodromic{{ n }}[1].w,
					  eye, ray, result);
		 result = intersectSphere(ID_COMPOUND_LOXODROMIC, {{ n }}, 2, MTL_TRANSPARENT,
					  u_compoundLoxodromic{{ n }}[2].xyz,
					  u_compoundLoxodromic{{ n }}[2].w,
					  eye, ray, result);
		 result = intersectSphere(ID_COMPOUND_LOXODROMIC, {{ n }}, 3, MTL_TRANSPARENT,
					  u_compoundLoxodromic{{ n }}[3].xyz,
					  u_compoundLoxodromic{{ n }}[3].w,
					  eye, ray, result);
		 result = intersectSphere(ID_COMPOUND_LOXODROMIC, {{ n }}, 4, MTL_TRANSPARENT,
					  u_compoundLoxodromic{{ n }}[4].xyz,
					  u_compoundLoxodromic{{ n }}[4].w,
					  eye, ray, result);
		 result = intersectSphere(ID_COMPOUND_LOXODROMIC, {{ n }}, 5, MTL_TRANSPARENT,
					  u_compoundLoxodromic{{ n }}[5].xyz,
					  50.,
					  eye, ray, result);
		 result = intersectSphere(ID_COMPOUND_LOXODROMIC, {{ n }}, 6, MTL_TRANSPARENT,
					  u_compoundLoxodromic{{ n }}[6].xyz,
					  50.,
					  eye, ray, result);
		 result = intersectSphere(ID_COMPOUND_LOXODROMIC, {{ n }}, 7, MTL_TRANSPARENT,
					  u_compoundLoxodromic{{ n }}[7].xyz,
					  50.,
					  eye, ray, result);
		 {% endfor %}
		 
	     }

	     if(result.x != NO_HIT){
		 vec3 normal = result.yzw;
		 vec3 intersection = eye + ray * result.x;

		 vec3 matColor = WHITE;
		 if( g_objId == ID_SCHOTTKY_SPHERE){
		     g_mtl = MTL_TRANSPARENT;
		     matColor = (g_objIndex == u_selectedObjectIndex &&
				 g_objId == u_selectedObjectId) ? RED : WHITE;
		 }else if(g_objId == ID_BASE_SPHERE){
		     matColor = (g_objId == u_selectedObjectId &&
				 g_objIndex == u_selectedObjectIndex) ? RED : GREEN;
		 }else if(g_objId == ID_AXIS_CYLINDER){
		     matColor = (g_objComponentId == u_selectedAxis) ? RED : WHITE;
		 }else if(g_objId == ID_TRANSFORM_BY_PLANES){
		     matColor = (g_objId == u_selectedObjectId &&
				 g_objIndex == u_selectedObjectIndex)?
				RED : BLUE;
		 }else if(g_objId == ID_TRANSFORM_BY_SPHERES){
		     matColor = (g_objComponentId == 0) ? LIGHT_BLUE : vec3(0.2, 0.2, 0.9);
		     matColor = (g_objComponentId == 1) ? YELLOW : matColor;
		     matColor = (g_objId == u_selectedObjectId &&
				 g_objIndex == u_selectedObjectIndex &&
				 g_objComponentId == u_selectedComponentId) ? RED : matColor;
		 }else if(g_objId == ID_COMPOUND_PARABOLIC){
		     matColor = (g_objComponentId == 0) ? LIGHT_BLUE : vec3(0.2, 0.2, 0.9);
		     matColor = (g_objComponentId == 1) ? YELLOW : matColor;
		     matColor = (g_objId == u_selectedObjectId &&
				 g_objIndex == u_selectedObjectIndex &&
				 g_objComponentId == u_selectedComponentId) ? RED : matColor;
		 }else if(g_objId == ID_COMPOUND_LOXODROMIC){
		     matColor = (g_objComponentId == 0) ? LIGHT_BLUE : vec3(0.2, 0.2, 0.9);
		     matColor = (g_objComponentId == 1) ? YELLOW : matColor;
		     matColor = (g_objComponentId == 3) ? PINK : matColor;
		     matColor = (g_objComponentId == 4) ? GREEN : matColor;
		     matColor = (g_objComponentId == 5) ? BLUE : matColor;
		     matColor = (g_objComponentId == 6) ? WHITE : matColor;
		     matColor = (g_objComponentId == 7) ? WHITE : matColor;
		 }else if(g_objId == ID_KLEIN_ORBIT){
		     matColor = hsv2rgb(vec3(0.1 + loopNum * 0.1 , 1., 1.));
		     normal = getNormal(intersection);
		 }

		 vec3 diffuse = diffuseLighting(intersection, normal, matColor,
						lightPos, lightPower);
		 vec3 ambient = matColor * ambientFactor;
		 if(g_mtl == MTL_TRANSPARENT){
		     coeff *= transparency;
		     l += (diffuse + ambient) * coeff;
		     eye = intersection + ray * 0.01;
		     continue;
		 }else{
		     l += (diffuse + ambient) * coeff;
		 }
	     }
	     break;
	 }
	 return l;
     }

     const float DISPLAY_GAMMA_COEFF = 1. / 2.2;
     vec3 gammaCorrect(vec3 rgb) {
	 return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),
		     (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),
		     (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));
     }

     const float SAMPLE_NUM = 1.;
     void main(){
	 /* vec4 sum = vec4(0);
	    for(float i = 0. ; i < SAMPLE_NUM ; i++){
	  *     vec2 coordOffset = rand2n(gl_FragCoord.xy, i);
	  *     vec3 ray = calcRay(u_eye, target, u_up, u_fov,
    	    u_iResolution.x, u_iResolution.y,
            gl_FragCoord.xy + coordOffset);
	  *     
	  *     sum += vec4(gammaCorrect(calcColor(u_eye, ray)), 1.);
	    }
	    gl_FragColor = vec4(sum/SAMPLE_NUM);*/
	 const vec2 coordOffset = vec2(0.5);
	 vec3 ray = calcRay(u_eye, u_target, u_up, u_fov,
			    u_iResolution.x, u_iResolution.y,
			    gl_FragCoord.xy + coordOffset);

	 gl_FragColor = vec4(gammaCorrect(calcColor(u_eye, ray)), 1.);
     }
    </script>
</head>
<body>
    <nav class="navbar">
	<div class="container">
            <div class="navbar-header">
		<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
		    <span class="sr-only">Toggle navigation</span>
		</button>
		<a class="navbar-brand">SchottkyLink</a>
            </div>
            <div id="navbar" class="collapse navbar-collapse">
		<ul class="nav navbar-nav">
		    <li class="active"><a href="../index.html">Home</a></li>
		</ul>
            </div>
	</div>
    </nav>

    <div class="container">
	<div class="row">
	    <div class="col-sm-5 col-md-3 sidebar-offcanvas">
		<div class="well">
		    <ul class="nav">
			<li><a href="../2d/index.html" data-cw="512" data-ch="512">
			    2 Dimensional </a></li>
			<li><a href="index.html" data-cw="512" data-ch="512">
			    3 Dimensional </a></li>
		    </ul>
		</div>
            </div>
	    <div class="col-sm-7 col-md-9">
	      <div id="content">
		<div class="canvas-area">
		  <h1>Schottky Link</h1>
		  <canvas id="canvas" width="256" height="256"></canvas>
		  <canvas id="orbitCanvas" width="512" height="512"></canvas>
		  <br>
		</div>
		Left Click : Select sphere<br>
		Double Click : Delete sphere<br>
		Wheel : Zoom<br>
		Wheel Drag : Move camera<br>
		z + Drag : Move selected sphere along the x axis<br>
		x + Drag : Move selected sphere along the y axis<br>
		c + Drag : Move selected sphere along the z axis<br>
		s + Drag : Tweak radius<br>
		Space : Add a Schottky sphere<br>
		b : Add a base sphere<br>
		+ / - : Increase / Decrease max iterations<br>
	      </div>
	    </div>
	</div>
    </div>

</body>
</html>
