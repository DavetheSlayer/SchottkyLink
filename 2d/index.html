<!DOCTYPE html>
<html><head>
    <title>SchottkyLink</title>
    <meta charset="UTF-8" />
    <!--  <link rel="stylesheet" type="text/css" href="scripts/style.css"> -->
    <style>
     body {
	 margin: 0;
     }
     canvas {
	 cursor: crosshair;
	 display:block;
	 background-color: black;
     }

    </style>
    <script type="text/javascript" src="../lib/nunjucks.min.js"></script>
    <script type="text/javascript" src="scripts/util.js"></script>
    <script type="text/javascript" src="scripts/main.js"></script>
    <script id="vs" type="x-shader/x-vertex">
     attribute vec3 position;

     void main(void){
	 gl_Position = vec4(position, 1.0);
     }
    </script>
    <script id="kissingSchottkyTemplate" type="x-shader/x-fragment">
     precision mediump float;
     uniform float iGlobalTime;
     //   uniform vec2  mouse;
     uniform vec2  iResolution;
     uniform vec2 translate;
     {% for n  in range(0,  numCircles ) %}
     uniform vec3 c{{ n }};
     {% endfor %}
     uniform float scale;
     uniform int iterations;

     // from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/
     vec2 rand2n(vec2 co, float sampleIndex) {
	 vec2 seed = co * (sampleIndex + 1.0);
	 seed+=vec2(-1,1);
	 // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html
	 return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),
                     fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));
     }
     
     vec2 circleInvert(vec2 pos, vec2 circlePos, float circleR){
	 return ((pos - circlePos) * circleR * circleR)/(distance(pos, circlePos) * distance(pos, circlePos) ) + circlePos;
     }

     const int MAX_ITERATIONS = 100;
     float IIS(vec2 pos){
	 float loopNum = 0.;
	 bool cont = false;
	 for(int i = 0 ; i < MAX_ITERATIONS ; i++){
	     if(i >= iterations) break;
	     cont = false;
	     {% if numCircles > 2 %}
	     {% for n  in range(0,  numCircles ) %}
	     {% if n == 0 %}
	     if(distance(pos, c0.xy) < c0.z){
		 pos = circleInvert(pos, c0.xy, c0.z);
		 cont = true;
		 loopNum++;
	     }
	     {% else %}
	     else if(distance(pos, c{{ n }}.xy) < c{{ n }}.z){
		 pos = circleInvert(pos, c{{ n }}.xy, c{{ n }}.z);
		 cont = true;
		 loopNum++;
	     }
	     {% endif %}
	     {% endfor %}
	     {% elif numCircles == 2 %}
	     if(distance(pos, c0.xy) < c0.z){
		 pos = circleInvert(pos, c0.xy, c0.z);
		 cont = true;
		 loopNum++;
	     }else if(distance(pos, c1.xy) < c1.z){
		 pos = circleInvert(pos, c1.xy, c1.z);
		 cont = true;
		 loopNum++;
	     }
	     {% else %}
	     if(distance(pos, c0.xy) < c0.z){
		 pos = circleInvert(pos, c0.xy, c0.z);
		 cont = true;
		 loopNum++;
	     }
	     {% endif %}
	     if(cont == false) break;
	 }
	 return loopNum;
     }
     vec3 hsv2rgb(vec3 c){
	 vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	 vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
	 return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
     }

     const float MAX_SAMPLE = 100.;
     uniform float initialHue;
     uniform float hueStep;
     uniform float numSamples;
     void main(){
	 vec4 sum = vec4(0);
	 float ratio = iResolution.x / iResolution.y / 2.0;
	 for(float i = 0. ; i < MAX_SAMPLE ; i++){
	     if(i >= numSamples) break;
	     vec2 position = ((gl_FragCoord.xy + rand2n(gl_FragCoord.xy, i)) / iResolution.yy ) - vec2(ratio, 0.5);
	     position = position * scale;
	     position += translate;

	     float loopNum = IIS(position);
	     if(loopNum > 0.){
		 vec3 hsv = vec3(initialHue + hueStep * loopNum, 1.0,1.0);
		 sum += vec4(hsv2rgb(hsv), 1.0);
	     }else{
		 sum += vec4(0.,0.,0.,1.);
	     }
	 }
	 gl_FragColor = vec4(sum/numSamples);
     }
    </script>

</head>
<body>
    <canvas id="canvas" width="512" height="512"></canvas>
</body>
</html>
