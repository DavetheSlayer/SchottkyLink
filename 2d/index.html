<!DOCTYPE html>
<html>
    <head>
        <title>SchottkyLink</title>
        <meta charset="UTF-8" />
        <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
        <link rel="stylesheet" href="../lib/keen-ui.min.css">
        <link rel="stylesheet" href="../css/style.css">
        <link rel="shortcut icon" href="../img/favicon.ico">
        <script type="text/javascript" src="../lib/vue.min.js"></script>
        <script type="text/javascript" src="../lib/keen-ui.min.js"></script>
        <script type="text/javascript" src="../lib/nunjucks.min.js"></script>
        <script type="text/javascript" src="scripts/util.js"></script>
        <script type="text/javascript" src="scripts/geometry.js"></script>
        <script type="text/javascript" src="scripts/presetParameter.js"></script>
        <script type="text/javascript" src="scripts/main.js"></script>
        <script id="vs" type="x-shader/x-vertex">
         attribute vec2 a_vertex;

         void main(void){
	     gl_Position = vec4(a_vertex, 0., 1.0);
         }
        </script>
        <script id="kissingSchottkyTemplate" type="x-shader/x-fragment">
         precision mediump float;
         uniform float u_iGlobalTime;
         uniform vec2  u_iResolution;
         uniform vec2 u_translate;
         uniform float u_scale;
         uniform int u_iterations;
         uniform float u_initialHue;
         uniform float u_hueStep;
         uniform float u_numSamples;

         uniform int u_selectedObjectId;
         uniform int u_selectedObjectIndex;
         uniform int u_selectedObjectComponentId;
         
         {% for n  in range(0,  numCircles ) %}
         // [x, y, r, r * r]
         uniform vec3 u_schottkyCircle{{ n }};
         // [centerRadius, circumferenceThickness];
         uniform vec2 u_schottkyCircleUIParam{{ n }};
         {% endfor %}

         {% for n  in range(0,  numInfiniteCircles ) %}
         // [x, y, degree]
         uniform vec3 u_infiniteCircle{{ n }};
         // [controlPointRadius, rotationControlCircleRadius, rotationControlCircleThickness]
         uniform vec3 u_infiniteCircleUIParam{{ n }};
         uniform mat2 u_infiniteCircleRotationMat2{{ n }};
         uniform mat2 u_invInfiniteCircleRotationMat2{{ n }};
         {% endfor %}

         const int ID_CIRCLE = 0;
         const int ID_INFINITE_CIRCLE = 1;
         
         {% for n in range(0, numTransformByCircles) %}
         //[innerCircle, outerCircle, invertedCircle]
         uniform vec3 u_transformByCircles{{ n }}[3];
         {% endfor %}

         {% for n in range(0, numTwistedLoxodromic) %}
         // [innerCircle, outerCircle, invertedCircle, c3, p]
         uniform vec3 u_twistedLoxodromic{{ n }}[5];
         uniform mat2 u_twistedLoxodromicRotationMat2{{ n }};
         uniform mat2 u_invTwistedLoxodromicRotationMat2{{ n }};
         // [controlPointRadius, lineThickness]
         uniform vec2 u_twistedLoxodromicUIParam{{ n }};
         {% endfor %}
         
         // from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/
         vec2 rand2n(vec2 co, float sampleIndex) {
	     vec2 seed = co * (sampleIndex + 1.0);
	     seed+=vec2(-1,1);
	     // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html
	     return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),
                         fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));
         }
         
         vec2 circleInvert(const vec2 pos, const vec2 circlePos, const float circleR){
	     return ((pos - circlePos) * circleR * circleR)/(distance(pos, circlePos) * distance(pos, circlePos) ) + circlePos;
         }

         const int MAX_ITERATIONS = 100;
         float IIS(vec2 pos){
	     float loopNum = 0.;
	     bool cont = false;
	     for(int i = 0 ; i < MAX_ITERATIONS ; i++){
	         if(i >= u_iterations) break;
	         cont = false;
	         {% if numCircles > 2 %}
	         {% for n  in range(0,  numCircles ) %}
	         {% if n == 0 %}
	         if(distance(pos, u_schottkyCircle0.xy) < u_schottkyCircle0.z){
		     pos = circleInvert(pos, u_schottkyCircle0.xy, u_schottkyCircle0.z);
		     cont = true;
		     loopNum++;
	         }
	         {% else %}
	         else if(distance(pos, u_schottkyCircle{{ n }}.xy) < u_schottkyCircle{{ n }}.z){
		     pos = circleInvert(pos, u_schottkyCircle{{ n }}.xy, u_schottkyCircle{{ n }}.z);
		     cont = true;
		     loopNum++;
	         }
	         {% endif %}
	         {% endfor %}
	         {% elif numCircles == 2 %}
	         if(distance(pos, u_schottkyCircle0.xy) < u_schottkyCircle0.z){
		     pos = circleInvert(pos, u_schottkyCircle0.xy, u_schottkyCircle0.z);
		     cont = true;
		     loopNum++;
	         }else if(distance(pos, u_schottkyCircle1.xy) < u_schottkyCircle1.z){
		     pos = circleInvert(pos, u_schottkyCircle1.xy, u_schottkyCircle1.z);
		     cont = true;
		     loopNum++;
	         }
	         {% elif numCircles == 1 %}
	         if(distance(pos, u_schottkyCircle0.xy) < u_schottkyCircle0.z){
		     pos = circleInvert(pos, u_schottkyCircle0.xy, u_schottkyCircle0.z);
		     cont = true;
		     loopNum++;
	         }
	         {% endif %}

	         {% for n in range(0,  numInfiniteCircles ) %}
	         pos -= u_infiniteCircle{{ n }}.xy;
	         pos = u_invInfiniteCircleRotationMat2{{ n }} * pos;
	         if(pos.x > 0.){
		     pos.x *= -1.;
		     cont = true;
		     loopNum++;
	         }
	         pos = u_infiniteCircleRotationMat2{{ n }} * pos;
	         pos += u_infiniteCircle{{ n }}.xy;
	         {% endfor %}

	         {% for n in range(0, numTransformByCircles) %}

	         if(distance(pos, u_transformByCircles{{ n }}[0].xy) < u_transformByCircles{{ n }}[0].z){
		     pos = circleInvert(pos, u_transformByCircles{{ n }}[0].xy, u_transformByCircles{{ n }}[0].z);
		     pos = circleInvert(pos, u_transformByCircles{{ n }}[1].xy, u_transformByCircles{{ n }}[1].z);
		     
		     cont = true;
                     //		 loopNum++;
	         }else if(distance(pos, u_transformByCircles{{ n }}[2].xy) >= u_transformByCircles{{ n }}[2].z){
		     pos = circleInvert(pos, u_transformByCircles{{ n }}[1].xy, u_transformByCircles{{ n }}[1].z);
		     pos = circleInvert(pos, u_transformByCircles{{ n }}[0].xy, u_transformByCircles{{ n }}[0].z);

		     cont = true;
                     //		 loopNum++;
	         }
	         
	         {% endfor %}

                 {% for n in range(0, numTwistedLoxodromic) %}
                 if(distance(pos, u_twistedLoxodromic{{ n }}[0].xy) < u_twistedLoxodromic{{ n }}[0].z){                 
                     /* vec2 v2{{ n }} = pos - u_twistedLoxodromic{{ n }}[0].xy;
                      * vec2 v1{{ n }} = normalize(u_twistedLoxodromic{{ n }}[1].xy - u_twistedLoxodromic{{ n }}[0].xy);
                      * vec2 projection{{ n }} = v1{{ n }} * dot(v1{{ n }}, v2{{ n }});
                      * vec2 n{{ n }} = normalize(v2{{ n }} - projection{{ n }});
                      * float d{{ n }} = length(n{{ n }});
                      * pos += -2. * d{{ n }} * n{{ n }};*/

                     pos -= u_twistedLoxodromic{{ n }}[0].xy;
	             pos = u_invTwistedLoxodromicRotationMat2{{ n }} * pos;
		     pos.x *= -1.;
	             pos = u_twistedLoxodromicRotationMat2{{ n }} * pos;
                     pos += u_twistedLoxodromic{{ n }}[0].xy;

                     
                     pos = circleInvert(pos, u_twistedLoxodromic{{ n }}[3].xy, u_twistedLoxodromic{{ n }}[3].z);
                     



                     pos = circleInvert(pos, u_twistedLoxodromic{{ n }}[0].xy, u_twistedLoxodromic{{ n }}[0].z);
                     pos = circleInvert(pos, u_twistedLoxodromic{{ n }}[1].xy, u_twistedLoxodromic{{ n }}[1].z);
                     
		     cont = true;
                     //		 loopNum++;
	         }else if(distance(pos, u_twistedLoxodromic{{ n }}[2].xy) >= u_twistedLoxodromic{{ n }}[2].z){
		     pos = circleInvert(pos, u_twistedLoxodromic{{ n }}[1].xy, u_twistedLoxodromic{{ n }}[1].z);
		     pos = circleInvert(pos, u_twistedLoxodromic{{ n }}[0].xy, u_twistedLoxodromic{{ n }}[0].z);

                     pos = circleInvert(pos, u_twistedLoxodromic{{ n }}[3].xy, u_twistedLoxodromic{{ n }}[3].z);
                     /* vec2 v2{{ n }} = pos - u_twistedLoxodromic{{ n }}[0].xy;
                      * vec2 v1{{ n }} = normalize(u_twistedLoxodromic{{ n }}[1].xy - u_twistedLoxodromic{{ n }}[0].xy);
                      * vec2 projection{{ n }} = v1{{ n }} * dot(v1{{ n }}, v2{{ n }});
                      * vec2 n{{ n }} = normalize(v2{{ n }} - projection{{ n }});
                      * float d{{ n }} = length(n{{ n }});
                      * pos += -2. * d{{ n }} * n{{ n }};*/
                     pos -= u_twistedLoxodromic{{ n }}[0].xy;
	             pos = u_invTwistedLoxodromicRotationMat2{{ n }} * pos;
		     pos.x *= -1.;
	             pos = u_twistedLoxodromicRotationMat2{{ n }} * pos;
                     pos += u_twistedLoxodromic{{ n }}[0].xy;

                     
		     cont = true;
                     //		 loopNum++;
	         }
                 
                 {% endfor %}
	         
	         if(cont == false) break;
	     }
	     return loopNum;
         }
         vec3 hsv2rgb(vec3 c){
	     vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	     vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
	     return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
         }

         const vec3 BLACK = vec3(0);
         const vec3 WHITE = vec3(1);
         vec3 renderUI(const vec2 position){
             {% for n in range(0, numCircles) %}
             if(u_selectedObjectId == ID_CIRCLE){
                 if(u_selectedObjectIndex == {{n}}){
                     float dist = distance(position, u_schottkyCircle{{ n }}.xy);
		     if(dist - u_schottkyCircle{{ n }}.z < 0. &&
                        dist > u_schottkyCircle{{ n }}.z - u_schottkyCircleUIParam{{ n }}.y ){
		         return WHITE;
		     }
	         }
             }
             {% endfor %}
             
	     {% for n in range(0, numTransformByCircles) %}
	     if(distance(position, u_transformByCircles{{ n }}[0].xy) < u_transformByCircles{{ n }}[0].z){
	         return vec3(.5, 0, 0);
	     }else if(distance(position, u_transformByCircles{{ n }}[1].xy) < u_transformByCircles{{ n }}[1].z){
	         return vec3(0, .5, 0);
	     }else if(distance(position, u_transformByCircles{{ n }}[2].xy) < u_transformByCircles{{ n }}[2].z){
	         return vec3(0, 0, .5);
	     }	     
	     {% endfor %}

             vec3 col = vec3(0.);

             {% for n in range(0, numTwistedLoxodromic) %}

             // line
             vec2 v2{{ n }} = position - u_twistedLoxodromic{{ n }}[0].xy;
             vec2 v1{{ n }} = normalize(u_twistedLoxodromic{{ n }}[1].xy - u_twistedLoxodromic{{ n }}[0].xy);
             vec2 projection{{ n }} = v1{{ n }} * dot(v1{{ n }}, v2{{ n }});
             vec2 n{{ n }} = v2{{ n }} - projection{{ n }};
             float d{{ n }} = length(n{{ n }});
             if(d{{ n }} < u_twistedLoxodromicUIParam{{ n }}.y){
                 return vec3(1);
             }

             if(distance(position, u_twistedLoxodromic{{ n }}[3].xy) < u_twistedLoxodromic{{ n }}[3].z){
	         col = vec3(0.5, .5, 0);
	     }

             // control point
             if(distance(position, u_twistedLoxodromic{{ n }}[4].xy) < u_twistedLoxodromicUIParam{{ n }}.x){
	         return vec3(1.);
             }

	     if(distance(position, u_twistedLoxodromic{{ n }}[0].xy) < u_twistedLoxodromic{{ n }}[0].z){
                 // inner circle
	         return mix(vec3(1., 0, 0), col, 0.5);
	     }else if(distance(position, u_twistedLoxodromic{{ n }}[1].xy) < u_twistedLoxodromic{{ n }}[1].z){
                 // outer circle
	         return mix(vec3(0, 1., 0), col, 0.5);
	     }else if(distance(position, u_twistedLoxodromic{{ n }}[2].xy) < u_twistedLoxodromic{{ n }}[2].z){
                 // inverted circle
	         return mix(vec3(0, 0, 1.), col, 0.5);
	     }else if(col != vec3(0.)){
                 return col;
             }
	     {% endfor %}
             
	     {% if numInfiniteCircles > 0 %}
	     if(u_selectedObjectId == ID_INFINITE_CIRCLE){
	         {% for n in range(0,  numInfiniteCircles ) %}
	         if(u_selectedObjectIndex == {{n}}){
		     if(distance(position, u_infiniteCircle{{ n }}.xy) < u_infiniteCircleUIParam{{ n }}.x){
		         return WHITE;
		     }
		     vec2 cp = vec2(u_infiniteCircleUIParam{{ n }}.y, 0);
		     vec2 pos = (position - (u_infiniteCircle{{ n }}.xy - u_infiniteCircleRotationMat2{{ n }} * cp));
		     if(length(pos) < u_infiniteCircleUIParam{{ n }}.x){
		         if(u_selectedObjectComponentId == 2){
			     return vec3(1, 0, 1);
		         }else{
			     return vec3(0, 1, 1);
		         }
		     }else if(abs(u_infiniteCircleUIParam{{ n }}.y - distance(position, u_infiniteCircle{{ n }}.xy)) <
		         u_infiniteCircleUIParam{{ n }}.z){
		         return WHITE;
		     }
	         }
	         {% endfor %}
	     }
	     
	     {% endif %}
	     return BLACK;
         }

         const float MAX_SAMPLE = 100.;
         void main(){
	     vec3 sum = vec3(0);
	     float ratio = u_iResolution.x / u_iResolution.y / 2.0;
	     for(float i = 0. ; i < MAX_SAMPLE ; i++){
	         if(i >= u_numSamples) break;
	         vec2 position = ((gl_FragCoord.xy + rand2n(gl_FragCoord.xy, i)) / u_iResolution.yy ) - vec2(ratio, 0.5);
	         position = position * u_scale;
	         position += u_translate;

	         vec3 col = renderUI(position);
	         float loopNum = IIS(position);
	         if(loopNum > 0.){
		     vec3 hsv = vec3(u_initialHue + u_hueStep * loopNum, 1.0, 1.0);
                     if(!all(equal(col, BLACK))){
                         sum += mix(hsv2rgb(hsv), col, 0.5);
                     }else{
                         sum += hsv2rgb(hsv);
                     }
	         }else{
                     sum += col;
                 }
	     }
	     gl_FragColor = vec4(sum/u_numSamples, 1.);
         }
        </script>
    </head>
    <body id="bodyElem">
        <header class="header">
            <ul class="headerLeft">
                <li class="myBtn"><a class="btnLink" href="../index.html">SchottkyLink</a></li>
                <li class="myBtn"><a class="btnLink" href="index.html">2D</a></li>
                <li class="myBtn"><a class="btnLink" href="../3d/index.html">3D</a></li>
            </ul>
            <ul class="headerRight">
                <li class="headerButton"><ui-button type="flat" raised color="primary" text="Save Scene"></ui-button></li>
                <li class="headerButton"><ui-button type="flat" raised color="primary" text="Load Scene"></ui-button></li>
            </ul>
    </header>
    <div class="content">
        <div class="renderPanel">
            <div class="renderCanvasPanel" id="panel1">
                <div id="canvasParent1" class="canvasParent">
                    <canvas class="renderCanvas" id="canvas"></canvas>
                </div>
                <div class="renderPropertyPanel">
                    <ui-button text="save" raised>
                    </ui-button>
                </div>
            </div>
        </div>
        <div class="propertyPanel">
            <ui-tabs fullwidth>
                <ui-tab header="Generator" id="tab-1">
                    <div class="imgBtn">
                        <div class="row">
                            <img src="../img/circle.png" width="128px" height="128px" />
                        </div>
                        <div class="row">
                            Circle
                        </div>
                    </div>
                    <div class="imgBtn">
                    <div class="row">
                        <img src="../img/infiniteCircle.png" width="128px" height="128px" />
                    </div>
                    <div class="row">
                        Infinite Circle
                    </div>
                    </div>
                    <div class="imgBtn">
                        <div class="row">
                            <img src="../img/compositionParabolic.png" width="128px" height="128px" />
                        </div>
                        <div class="row">
                            Composition (Parabolic)
                        </div>
                    </div>
                    <div class="imgBtn">
                        <div class="row">
                            <img src="../img/compositionLoxodromic.png" width="128px" height="128px" />
                        </div>
                        <div class="row">
                            Composition (Loxodromic)
                        </div>
                    </div>
                </ui-tab>
                <ui-tab header="Scene" id="tab-2">
                </ui-tab>
            </ui-tabs>
        </div>
    </div>
    <footer class="footer">
        <a id="ghLink" href="https://github.com/soma-arc/SchottkyLink"
           target="_blank">
            <img src="../img/GitHub-Mark-32px.png" class="imgLink"/>
        </a>
        Created by soma_arc
    </footer>
    </body>
</html>
