<!DOCTYPE html>
<html><head>
    <title>SchottkyLink</title>
    <meta charset="UTF-8" />
    <!--  <link rel="stylesheet" type="text/css" href="scripts/style.css"> -->
    <style>
     body {
	 margin: 0;
     }
     canvas {
	 cursor: crosshair;
	 display:block;
	 background-color: black;
     }
    </style>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="../lib/bootstrap.min.css" rel="stylesheet">
    <script type="text/javascript" src="../lib/nunjucks.min.js"></script>
    <script type="text/javascript" src="scripts/util.js"></script>
    <script type="text/javascript" src="scripts/main.js"></script>
    <script id="vs" type="x-shader/x-vertex">
     attribute vec3 position;

     void main(void){
	 gl_Position = vec4(position, 1.0);
     }
    </script>
    <script id="kissingSchottkyTemplate" type="x-shader/x-fragment">
     precision mediump float;
     uniform float u_iGlobalTime;
     uniform vec2  u_iResolution;
     uniform vec2 u_translate;
     uniform float u_scale;
     uniform int u_iterations;
     uniform float u_initialHue;
     uniform float u_hueStep;
     uniform float u_numSamples;

     uniform int u_selectedObjectId;
     uniform int u_selectedObjectIndex;
     uniform int u_selectedObjectComponentId;
     
     {% for n  in range(0,  numCircles ) %}
     // [x, y, r, r * r]
     uniform vec3 u_schottkyCircle{{ n }};
     // [centerRadius, circumferenceThickness];
     uniform vec2 u_schottkyCircleUIParam{{ n }};
     {% endfor %}

     {% for n  in range(0,  numInfiniteCircles ) %}
     // [x, y, degree]
     uniform vec3 u_infiniteCircle{{ n }};
     // [controlPointRadius, rotationControlCircleRadius, rotationControlCircleThickness]
     uniform vec3 u_infiniteCircleUIParam{{ n }};
     uniform mat2 u_infiniteCircleRotationMat2{{ n }};
     uniform mat2 u_invInfiniteCircleRotationMat2{{ n }};
     {% endfor %}

     const int ID_CIRCLE = 0;
     const int ID_INFINITE_CIRCLE = 1;

     const int CIRCLE_BODY = 0;
     const int CIRCLE_CIRCUMFERENCE = 1;
     
     {% for n in range(0, numTransformByCircles) %}
     //[innerCircle, outerCircle, invertedCircle]
     uniform vec3 u_transformByCircles{{ n }}[3];
     {% endfor %}

     // from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/
     vec2 rand2n(vec2 co, float sampleIndex) {
	 vec2 seed = co * (sampleIndex + 1.0);
	 seed+=vec2(-1,1);
	 // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html
	 return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),
                     fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));
     }
     
     vec2 circleInvert(const vec2 pos, const vec2 circlePos, const float circleR){
	 return ((pos - circlePos) * circleR * circleR)/(distance(pos, circlePos) * distance(pos, circlePos) ) + circlePos;
     }

     const int MAX_ITERATIONS = 100;
     float IIS(vec2 pos){
	 float loopNum = 0.;
	 bool cont = false;
	 for(int i = 0 ; i < MAX_ITERATIONS ; i++){
	     if(i >= u_iterations) break;
	     cont = false;
	     {% if numCircles > 2 %}
	     {% for n  in range(0,  numCircles ) %}
	     {% if n == 0 %}
	     if(distance(pos, u_schottkyCircle0.xy) < u_schottkyCircle0.z){
		 pos = circleInvert(pos, u_schottkyCircle0.xy, u_schottkyCircle0.z);
		 cont = true;
		 loopNum++;
	     }
	     {% else %}
	     else if(distance(pos, u_schottkyCircle{{ n }}.xy) < u_schottkyCircle{{ n }}.z){
		 pos = circleInvert(pos, u_schottkyCircle{{ n }}.xy, u_schottkyCircle{{ n }}.z);
		 cont = true;
		 loopNum++;
	     }
	     {% endif %}
	     {% endfor %}
	     {% elif numCircles == 2 %}
	     if(distance(pos, u_schottkyCircle0.xy) < u_schottkyCircle0.z){
		 pos = circleInvert(pos, u_schottkyCircle0.xy, u_schottkyCircle0.z);
		 cont = true;
		 loopNum++;
	     }else if(distance(pos, u_schottkyCircle1.xy) < u_schottkyCircle1.z){
		 pos = circleInvert(pos, u_schottkyCircle1.xy, u_schottkyCircle1.z);
		 cont = true;
		 loopNum++;
	     }
	     {% elif numCircles == 1 %}
	     if(distance(pos, u_schottkyCircle0.xy) < u_schottkyCircle0.z){
		 pos = circleInvert(pos, u_schottkyCircle0.xy, u_schottkyCircle0.z);
		 cont = true;
		 loopNum++;
	     }
	     {% endif %}

	     {% for n in range(0,  numInfiniteCircles ) %}
	     pos -= u_infiniteCircle{{ n }}.xy;
	     pos = u_invInfiniteCircleRotationMat2{{ n }} * pos;
	     if(pos.x > 0.){
		 pos.x *= -1.;
		 cont = true;
		 loopNum++;
	     }
	     pos = u_infiniteCircleRotationMat2{{ n }} * pos;
	     pos += u_infiniteCircle{{ n }}.xy;
	     {% endfor %}

	     {% for n in range(0, numTransformByCircles) %}

	     if(distance(pos, u_transformByCircles{{ n }}[0].xy) < u_transformByCircles{{ n }}[0].z){
		 pos = circleInvert(pos, u_transformByCircles{{ n }}[0].xy, u_transformByCircles{{ n }}[0].z);
		 pos = circleInvert(pos, u_transformByCircles{{ n }}[1].xy, u_transformByCircles{{ n }}[1].z);
		 
		 cont = true;
//		 loopNum++;
	     }else if(distance(pos, u_transformByCircles{{ n }}[2].xy) >= u_transformByCircles{{ n }}[2].z){
		 pos = circleInvert(pos, u_transformByCircles{{ n }}[1].xy, u_transformByCircles{{ n }}[1].z);
		 pos = circleInvert(pos, u_transformByCircles{{ n }}[0].xy, u_transformByCircles{{ n }}[0].z);

		 cont = true;
//		 loopNum++;
	     }
	     
	     {% endfor %}
	     
	     if(cont == false) break;
	 }
	 return loopNum;
     }
     vec3 hsv2rgb(vec3 c){
	 vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	 vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
	 return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
     }

     const vec3 BLACK = vec3(0);
     const vec3 WHITE = vec3(1);
     vec3 renderUI(const vec2 position){
         {% for n in range(0, numCircles) %}
         if(u_selectedObjectId == ID_CIRCLE){
             if(u_selectedObjectIndex == {{n}}){
                 float dist = distance(position, u_schottkyCircle{{ n }}.xy);
		 if(dist - u_schottkyCircle{{ n }}.z < 0. &&
                    dist > u_schottkyCircle{{ n }}.z - u_schottkyCircleUIParam{{ n }}.y ){
		     return WHITE;
		 }
	     }
         }
         {% endfor %}
         
	 {% for n in range(0, numTransformByCircles) %}
	 if(distance(position, u_transformByCircles{{ n }}[0].xy) < u_transformByCircles{{ n }}[0].z){
	     return vec3(.5, 0, 0);
	 }else if(distance(position, u_transformByCircles{{ n }}[1].xy) < u_transformByCircles{{ n }}[1].z){
	     return vec3(0, .5, 0);
	 }else if(distance(position, u_transformByCircles{{ n }}[2].xy) < u_transformByCircles{{ n }}[2].z){
	     return vec3(0, 0, .5);
	 }	     
	 {% endfor %}

	 {% if numInfiniteCircles > 0 %}
	 if(u_selectedObjectId == ID_INFINITE_CIRCLE){
	     {% for n in range(0,  numInfiniteCircles ) %}
	     if(u_selectedObjectIndex == {{n}}){
		 if(distance(position, u_infiniteCircle{{ n }}.xy) < u_infiniteCircleUIParam{{ n }}.x){
		     return WHITE;
		 }
		 vec2 cp = vec2(u_infiniteCircleUIParam{{ n }}.y, 0);
		 vec2 pos = (position - (u_infiniteCircle{{ n }}.xy - u_infiniteCircleRotationMat2{{ n }} * cp));
		 if(length(pos) < u_infiniteCircleUIParam{{ n }}.x){
		     if(u_selectedObjectComponentId == 2){
			 return vec3(1, 0, 1);
		     }else{
			 return vec3(0, 1, 1);
		     }
		 }else if(abs(u_infiniteCircleUIParam{{ n }}.y - distance(position, u_infiniteCircle{{ n }}.xy)) <
		     u_infiniteCircleUIParam{{ n }}.z){
		     return WHITE;
		 }
	     }
	     {% endfor %}
	 }
	 
	 {% endif %}
	 return BLACK;
     }

     const float MAX_SAMPLE = 100.;
     void main(){
	 vec3 sum = vec3(0);
	 float ratio = u_iResolution.x / u_iResolution.y / 2.0;
	 for(float i = 0. ; i < MAX_SAMPLE ; i++){
	     if(i >= u_numSamples) break;
	     vec2 position = ((gl_FragCoord.xy + rand2n(gl_FragCoord.xy, i)) / u_iResolution.yy ) - vec2(ratio, 0.5);
	     position = position * u_scale;
	     position += u_translate;

	     vec3 col = renderUI(position);
	     if(!all(equal(col, BLACK))){
		 sum += col;
		 continue;
	     }
	     float loopNum = IIS(position);
	     if(loopNum > 0.){
		 vec3 hsv = vec3(u_initialHue + u_hueStep * loopNum, 1.0, 1.0);
		 sum += hsv2rgb(hsv);
	     }
	 }
	 gl_FragColor = vec4(sum/u_numSamples, 1.);
     }
    </script>

</head>
<body>
    <div id="main-area">
	<nav class="navbar">
	    <div class="container">
		<div class="navbar-header">
		    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
			<span class="sr-only">Toggle navigation</span>
		    </button>
		    <a class="navbar-brand">SchottkyLink</a>
		</div>
		<div id="navbar" class="collapse navbar-collapse">
		    <ul class="nav navbar-nav">
			<li class="active"><a href="../index.html">Home</a></li>
		    </ul>
		</div>
	    </div>
	</nav>

	<div class="container">
	    <div class="row">
		<div class="col-sm-5 col-md-3 sidebar-offcanvas">
		    <div class="well">
			<ul class="nav">
			    <li><a href="index.html" data-cw="512" data-ch="512">
				2 Dimensional </a></li>
			    <li><a href="../3d/index.html" data-cw="512" data-ch="512">
				3 Dimensional </a></li>
			</ul>
		    </div>
		</div>
		<div class="col-sm-7 col-md-9">
		    <div id="content">
			<h1>Schottky Link</h1>
			<div class="canvas-area">
			    <canvas id="canvas" width="720" height="480"></canvas>
			</div>
			Wheel : Zoom<br>
			Wheel Button : Add a circle<br>
			Mouse Drag : Move circle / Tweak radius<br>
			Double Click : Delete a circle<br>
			Arrow Key : Move camera<br>
			p / n : Increase / Decrease number of samples<br>
			+ / - : Increase / Decrease max iterations
		    </div>
		</div>
	    </div>
	</div>
    </div>
</body>
</html>
